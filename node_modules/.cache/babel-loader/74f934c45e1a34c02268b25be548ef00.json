{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction useScroll(nodeRef, onChange) {\n  var _React$useState = React.useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var onChangeRef = React.useRef();\n  onChangeRef.current = onChange;\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element) {\n      onChangeRef.current({\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    var handler = function handler(e) {\n      onChangeRef.current({\n        scrollLeft: e.target.scrollLeft,\n        scrollTop: e.target.scrollTop\n      });\n    };\n\n    if (element) {\n      element.addEventListener('scroll', handler, {\n        capture: false,\n        passive: true\n      });\n      return function () {\n        element.removeEventListener('scroll', handler);\n      };\n    }\n  }, [element]);\n}\n\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nfunction useRect(nodeRef) {\n  var _React$useState = React.useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var _React$useState2 = React.useState(null),\n      rect = _React$useState2[0],\n      setRect = _React$useState2[1];\n\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  React.useEffect(function () {\n    var observer;\n\n    if (element) {\n      observer = observeRect(element, setRect);\n    }\n\n    observer && observer.observe();\n    return function () {\n      observer && observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\n\nfunction useVirtual(_ref) {\n  var _ref3, _measurements2;\n\n  var _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0 : _ref$size,\n      estimateSize = _ref.estimateSize,\n      _ref$overscan = _ref.overscan,\n      overscan = _ref$overscan === void 0 ? 0 : _ref$overscan,\n      parentRef = _ref.parentRef,\n      horizontal = _ref.horizontal,\n      scrollToFn = _ref.scrollToFn;\n  var sizeKey = horizontal ? 'width' : 'height';\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n  var defaultScrollToFn = React.useCallback(function (offset) {\n    parentRef.current[scrollKey] = offset;\n  }, [parentRef, scrollKey]);\n  scrollToFn = scrollToFn || defaultScrollToFn;\n\n  var _ref2 = useRect(parentRef) || (_ref3 = {}, _ref3[sizeKey] = 0, _ref3),\n      outerSize = _ref2[sizeKey];\n\n  var _React$useState = React.useState(0),\n      scrollOffset = _React$useState[0],\n      _setScrollOffset = _React$useState[1];\n\n  useScroll(parentRef, function (_ref4) {\n    var newScrollOffset = _ref4[scrollKey];\n\n    _setScrollOffset(newScrollOffset);\n  });\n  var scrollOffsetPlusOuterSize = scrollOffset + outerSize;\n\n  var _React$useState2 = React.useState({}),\n      measuredCache = _React$useState2[0],\n      setMeasuredCache = _React$useState2[1];\n\n  var mountedRef = React.useRef();\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({});\n    }\n\n    mountedRef.current = true;\n  }, [estimateSize, size]);\n\n  var _React$useMemo = React.useMemo(function () {\n    var measurements = [];\n    var reversedMeasurements = [];\n\n    for (var i = 0, j = size - 1; i < size; i++, j--) {\n      var _measurements;\n\n      var _start = ((_measurements = measurements[i - 1]) == null ? void 0 : _measurements.end) || 0;\n\n      var _size = measuredCache[i] || estimateSize(i);\n\n      var _end = _start + _size;\n\n      var bounds = {\n        index: i,\n        start: _start,\n        size: _size,\n        end: _end\n      };\n      measurements[i] = _extends({}, bounds);\n      reversedMeasurements[j] = _extends({}, bounds);\n    }\n\n    return {\n      measurements: measurements,\n      reversedMeasurements: reversedMeasurements\n    };\n  }, [estimateSize, measuredCache, size]),\n      measurements = _React$useMemo.measurements,\n      reversedMeasurements = _React$useMemo.reversedMeasurements;\n\n  var totalSize = ((_measurements2 = measurements[size - 1]) == null ? void 0 : _measurements2.end) || 0;\n  var start = React.useMemo(function () {\n    return measurements.find(function (rowStat) {\n      return rowStat.end >= scrollOffset;\n    });\n  }, [measurements, scrollOffset]);\n  var end = React.useMemo(function () {\n    return reversedMeasurements.find(function (rowStat) {\n      return rowStat.start <= scrollOffsetPlusOuterSize;\n    });\n  }, [measurements, scrollOffsetPlusOuterSize]);\n  var startIndex = start ? start.index : 0;\n  var endIndex = end ? end.index : 0; // Always add at least one overscan item, so focus will work\n\n  startIndex = Math.max(startIndex - 1 - overscan, 0);\n  endIndex = Math.min(endIndex + 1 + overscan, size - 1);\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n\n    var _loop = function _loop(i) {\n      var measurement = measurements[i];\n\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          if (!el) return;\n\n          var _el$getBoundingClient = el.getBoundingClientRect(),\n              measuredSize = _el$getBoundingClient[sizeKey];\n\n          if (measuredSize !== item.size) {\n            setMeasuredCache(function (old) {\n              var _extends2;\n\n              return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[i] = measuredSize, _extends2));\n            });\n          }\n        }\n      });\n\n      virtualItems.push(item);\n    };\n\n    for (var i = startIndex; i <= endIndex; i++) {\n      _loop(i);\n    }\n\n    return virtualItems;\n  }, [startIndex, endIndex, measurements, sizeKey]);\n  var latestRef = React.useRef();\n  latestRef.current = {\n    measurements: measurements,\n    outerSize: outerSize,\n    scrollOffset: scrollOffset,\n    scrollOffsetPlusOuterSize: scrollOffsetPlusOuterSize,\n    totalSize: totalSize\n  };\n  var scrollToOffset = React.useCallback(function (offset, _temp) {\n    var _ref5 = _temp === void 0 ? {} : _temp,\n        _ref5$align = _ref5.align,\n        align = _ref5$align === void 0 ? 'start' : _ref5$align;\n\n    var _latestRef$current = latestRef.current,\n        outerSize = _latestRef$current.outerSize,\n        scrollOffset = _latestRef$current.scrollOffset,\n        scrollOffsetPlusOuterSize = _latestRef$current.scrollOffsetPlusOuterSize,\n        totalSize = _latestRef$current.totalSize;\n    offset = Math.max(0, Math.min(offset, totalSize - outerSize));\n\n    if (align === 'auto') {\n      if (offset <= scrollOffset) {\n        align = 'start';\n      } else if (offset >= scrollOffsetPlusOuterSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n\n    if (align === 'start') {\n      scrollToFn(offset);\n    } else if (align === 'end') {\n      scrollToFn(offset - outerSize);\n    } else if (align === 'center') {\n      scrollToFn(offset - outerSize / 2);\n    }\n  }, [scrollToFn]);\n  var scrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref6 = _temp2 === void 0 ? {} : _temp2,\n        _ref6$align = _ref6.align,\n        align = _ref6$align === void 0 ? 'auto' : _ref6$align;\n\n    var _latestRef$current2 = latestRef.current,\n        measurements = _latestRef$current2.measurements,\n        scrollOffset = _latestRef$current2.scrollOffset,\n        scrollOffsetPlusOuterSize = _latestRef$current2.scrollOffsetPlusOuterSize;\n    var measurement = measurements[index];\n\n    if (!measurement) {\n      return;\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffsetPlusOuterSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n\n    var offset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(offset, {\n      align: align\n    });\n  }, [scrollToOffset]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex\n  };\n}\n\nexport { useVirtual };","map":{"version":3,"sources":["../src/useIsomorphicLayoutEffect.js","../src/useScroll.js","../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useRect.js","../src/index.js"],"names":["React","element","setElement","nodeRef","onChangeRef","useIsomorphicLayoutEffect","scrollLeft","scrollTop","handler","e","capture","passive","props","rectChanged","b","observedNodes","run","changedStates","newRect","node","state","rafId","window","observeRect","cb","observe","wasEmpty","rect","hasRectChanged","callbacks","unobserve","index","cancelAnimationFrame","setRect","initialRectSet","observer","size","estimateSize","overscan","parentRef","horizontal","scrollToFn","sizeKey","scrollKey","defaultScrollToFn","outerSize","useRect","scrollOffset","_setScrollOffset","useScroll","newScrollOffset","scrollOffsetPlusOuterSize","measuredCache","setMeasuredCache","mountedRef","measurements","reversedMeasurements","i","j","start","end","bounds","totalSize","rowStat","startIndex","endIndex","Math","virtualItems","measurement","item","measureRef","measuredSize","el","latestRef","scrollToOffset","align","offset","scrollToIndex"],"mappings":"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","sourcesContent":["import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useScroll(nodeRef, onChange) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const onChangeRef = React.useRef()\n  onChangeRef.current = onChange\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element) {\n      onChangeRef.current({\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop,\n      })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    const handler = e => {\n      onChangeRef.current({\n        scrollLeft: e.target.scrollLeft,\n        scrollTop: e.target.scrollTop,\n      })\n    }\n\n    if (element) {\n      element.addEventListener('scroll', handler, {\n        capture: false,\n        passive: true,\n      })\n\n      return () => {\n        element.removeEventListener('scroll', handler)\n      }\n    }\n  }, [element])\n}\n","var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, setRect] = React.useState(null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      setRect(element.getBoundingClientRect())\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    let observer\n\n    if (element) {\n      observer = observeRect(element, setRect)\n    }\n\n    observer && observer.observe()\n\n    return () => {\n      observer && observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n","import React from 'react'\n\nimport useScroll from './useScroll'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport function useVirtual({\n  size = 0,\n  estimateSize,\n  overscan = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      parentRef.current[scrollKey] = offset\n    },\n    [parentRef, scrollKey]\n  )\n\n  scrollToFn = scrollToFn || defaultScrollToFn\n\n  const { [sizeKey]: outerSize } = useRect(parentRef) || {\n    [sizeKey]: 0,\n  }\n\n  const [scrollOffset, _setScrollOffset] = React.useState(0)\n\n  useScroll(parentRef, ({ [scrollKey]: newScrollOffset }) => {\n    _setScrollOffset(newScrollOffset)\n  })\n\n  const scrollOffsetPlusOuterSize = scrollOffset + outerSize\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize, size])\n\n  const { measurements, reversedMeasurements } = React.useMemo(() => {\n    const measurements = []\n    const reversedMeasurements = []\n\n    for (let i = 0, j = size - 1; i < size; i++, j--) {\n      const start = measurements[i - 1]?.end || 0\n      const size = measuredCache[i] || estimateSize(i)\n      const end = start + size\n      const bounds = { index: i, start, size, end }\n      measurements[i] = {\n        ...bounds,\n      }\n      reversedMeasurements[j] = {\n        ...bounds,\n      }\n    }\n    return { measurements, reversedMeasurements }\n  }, [estimateSize, measuredCache, size])\n\n  const totalSize = measurements[size - 1]?.end || 0\n\n  let start = React.useMemo(\n    () => measurements.find(rowStat => rowStat.end >= scrollOffset),\n    [measurements, scrollOffset]\n  )\n  let end = React.useMemo(\n    () =>\n      reversedMeasurements.find(\n        rowStat => rowStat.start <= scrollOffsetPlusOuterSize\n      ),\n    [measurements, scrollOffsetPlusOuterSize]\n  )\n\n  let startIndex = start ? start.index : 0\n  let endIndex = end ? end.index : 0\n\n  // Always add at least one overscan item, so focus will work\n  startIndex = Math.max(startIndex - 1 - overscan, 0)\n  endIndex = Math.min(endIndex + 1 + overscan, size - 1)\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let i = startIndex; i <= endIndex; i++) {\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (!el) return\n\n          const { [sizeKey]: measuredSize } = el.getBoundingClientRect()\n\n          if (measuredSize !== item.size) {\n            setMeasuredCache(old => ({\n              ...old,\n              [i]: measuredSize,\n            }))\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [startIndex, endIndex, measurements, sizeKey])\n\n  const latestRef = React.useRef()\n  latestRef.current = {\n    measurements,\n    outerSize,\n    scrollOffset,\n    scrollOffsetPlusOuterSize,\n    totalSize,\n  }\n\n  const scrollToOffset = React.useCallback(\n    (offset, { align = 'start' } = {}) => {\n      const {\n        outerSize,\n        scrollOffset,\n        scrollOffsetPlusOuterSize,\n        totalSize,\n      } = latestRef.current\n\n      offset = Math.max(0, Math.min(offset, totalSize - outerSize))\n\n      if (align === 'auto') {\n        if (offset <= scrollOffset) {\n          align = 'start'\n        } else if (offset >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(offset)\n      } else if (align === 'end') {\n        scrollToFn(offset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(offset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (index, { align = 'auto' } = {}) => {\n      const {\n        measurements,\n        scrollOffset,\n        scrollOffsetPlusOuterSize,\n      } = latestRef.current\n\n      const measurement = measurements[index]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      let offset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n      scrollToOffset(offset, { align })\n    },\n    [scrollToOffset]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}