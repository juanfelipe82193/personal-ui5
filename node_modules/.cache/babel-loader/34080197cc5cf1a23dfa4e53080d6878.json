{"ast":null,"code":"const findClosingParenthesisPos = (str, openingParenthesisPos) => {\n  let opened = 1;\n\n  for (let pos = openingParenthesisPos + 1; pos < str.length; pos++) {\n    const char = str.charAt(pos);\n\n    if (char === \"(\") {\n      opened++;\n    } else if (char === \")\") {\n      opened--;\n    }\n\n    if (opened === 0) {\n      return pos;\n    }\n  }\n};\n\nconst replaceSelector = (str, selector, selectorStartPos, replacement) => {\n  const charAfterSelectorPos = selectorStartPos + selector.length;\n  const charAfterSelector = str.charAt(charAfterSelectorPos);\n  const upToSelector = str.substring(0, selectorStartPos) + replacement;\n\n  if (charAfterSelector === \"(\") {\n    const closingParenthesisPos = findClosingParenthesisPos(str, charAfterSelectorPos);\n    return upToSelector + str.substring(charAfterSelectorPos + 1, closingParenthesisPos) + str.substring(closingParenthesisPos + 1);\n  }\n\n  return upToSelector + str.substring(charAfterSelectorPos);\n};\n/**\n * :host => ui5-button\n * :host([expr]) => ui5-button[expr]\n * ::slotted(expr) => expr\n * @param str - source string\n * @param selector - :host or ::slotted\n * @param replacement - normally tag name\n * @returns {*}\n */\n\n\nconst replaceSelectors = (str, selector, replacement) => {\n  let selectorStartPos = str.indexOf(selector);\n\n  while (selectorStartPos !== -1) {\n    str = replaceSelector(str, selector, selectorStartPos, replacement);\n    selectorStartPos = str.indexOf(selector);\n  }\n\n  return str;\n};\n\nconst adaptLinePart = (line, tag) => {\n  line = line.trim();\n  line = replaceSelectors(line, \"::slotted\", ``); // first remove all ::slotted() occurrences\n  // Host selector - replace it\n\n  if (line.startsWith(\":host\")) {\n    return replaceSelector(line, \":host\", 0, tag);\n  } // Leave out @keyframes and keyframe values (0%, 100%, etc...)\n  // csso shortens '100%' -> 'to', make sure to leave it untouched\n\n\n  if (line.match(/^[@0-9]/) || line === \"to\" || line === \"to{\") {\n    return line;\n  } // IE specific selector (directly written with the tag) - keep it\n\n\n  if (line.match(new RegExp(`^${tag}[^a-zA-Z0-9-]`))) {\n    return line;\n  } // No host and no tag in the beginning of the selector - prepend the tag\n\n\n  return `${tag} ${line}`;\n};\n\nconst adaptCSSForIE = (str, tag) => {\n  str = str.replace(/\\n/g, ` `);\n  str = str.replace(/([{}])/g, `$1\\n`);\n  let result = ``;\n  const lines = str.split(`\\n`);\n  lines.forEach(line => {\n    const mustProcess = line.match(/{$/); // Only work on lines that end on {, otherwise just append to result\n\n    if (mustProcess) {\n      const lineParts = line.split(\",\");\n      const processedLineParts = lineParts.map(linePart => {\n        return adaptLinePart(linePart, tag);\n      });\n      line = processedLineParts.join(\",\");\n    }\n\n    result = `${result}${line}`;\n  });\n  return result;\n};\n\nexport default adaptCSSForIE;","map":{"version":3,"sources":["/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/@ui5/webcomponents-base/dist/theming/adaptCSSForIE.js"],"names":["findClosingParenthesisPos","str","openingParenthesisPos","opened","pos","length","char","charAt","replaceSelector","selector","selectorStartPos","replacement","charAfterSelectorPos","charAfterSelector","upToSelector","substring","closingParenthesisPos","replaceSelectors","indexOf","adaptLinePart","line","tag","trim","startsWith","match","RegExp","adaptCSSForIE","replace","result","lines","split","forEach","mustProcess","lineParts","processedLineParts","map","linePart","join"],"mappings":"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","sourcesContent":["const findClosingParenthesisPos = (str, openingParenthesisPos) => {\n\tlet opened = 1;\n\tfor (let pos = openingParenthesisPos + 1; pos < str.length; pos++) {\n\t\tconst char = str.charAt(pos);\n\t\tif (char === \"(\") {\n\t\t\topened++;\n\t\t} else if (char === \")\") {\n\t\t\topened--;\n\t\t}\n\t\tif (opened === 0) {\n\t\t\treturn pos;\n\t\t}\n\t}\n};\n\nconst replaceSelector = (str, selector, selectorStartPos, replacement) => {\n\tconst charAfterSelectorPos = selectorStartPos + selector.length;\n\tconst charAfterSelector = str.charAt(charAfterSelectorPos);\n\n\tconst upToSelector = str.substring(0, selectorStartPos) + replacement;\n\tif (charAfterSelector === \"(\") {\n\t\tconst closingParenthesisPos = findClosingParenthesisPos(str, charAfterSelectorPos);\n\t\treturn upToSelector + str.substring(charAfterSelectorPos + 1, closingParenthesisPos) + str.substring(closingParenthesisPos + 1);\n\t}\n\n\treturn upToSelector + str.substring(charAfterSelectorPos);\n};\n\n/**\n * :host => ui5-button\n * :host([expr]) => ui5-button[expr]\n * ::slotted(expr) => expr\n * @param str - source string\n * @param selector - :host or ::slotted\n * @param replacement - normally tag name\n * @returns {*}\n */\nconst replaceSelectors = (str, selector, replacement) => {\n\tlet selectorStartPos = str.indexOf(selector);\n\twhile (selectorStartPos !== -1) {\n\t\tstr = replaceSelector(str, selector, selectorStartPos, replacement);\n\t\tselectorStartPos = str.indexOf(selector);\n\t}\n\treturn str;\n};\n\nconst adaptLinePart = (line, tag) => {\n\tline = line.trim();\n\tline = replaceSelectors(line, \"::slotted\", ``); // first remove all ::slotted() occurrences\n\n\t// Host selector - replace it\n\tif (line.startsWith(\":host\")) {\n\t\treturn replaceSelector(line, \":host\", 0, tag);\n\t}\n\n\t// Leave out @keyframes and keyframe values (0%, 100%, etc...)\n\t// csso shortens '100%' -> 'to', make sure to leave it untouched\n\tif (line.match(/^[@0-9]/) || line === \"to\" || line === \"to{\") {\n\t\treturn line;\n\t}\n\n\t// IE specific selector (directly written with the tag) - keep it\n\tif (line.match(new RegExp(`^${tag}[^a-zA-Z0-9-]`))) {\n\t\treturn line;\n\t}\n\n\t// No host and no tag in the beginning of the selector - prepend the tag\n\treturn `${tag} ${line}`;\n};\n\nconst adaptCSSForIE = (str, tag) => {\n\tstr = str.replace(/\\n/g, ` `);\n\tstr = str.replace(/([{}])/g, `$1\\n`);\n\tlet result = ``;\n\tconst lines = str.split(`\\n`);\n\tlines.forEach(line => {\n\t\tconst mustProcess = line.match(/{$/); // Only work on lines that end on {, otherwise just append to result\n\t\tif (mustProcess) {\n\t\t\tconst lineParts = line.split(\",\");\n\t\t\tconst processedLineParts = lineParts.map(linePart => {\n\t\t\t\treturn adaptLinePart(linePart, tag);\n\t\t\t});\n\t\t\tline = processedLineParts.join(\",\");\n\t\t}\n\t\tresult = `${result}${line}`;\n\t});\n\treturn result;\n};\n\nexport default adaptCSSForIE;\n"]},"metadata":{},"sourceType":"module"}