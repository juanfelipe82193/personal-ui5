{"ast":null,"code":"import _get from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createForOfIteratorHelper from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport var isPrimitive = function isPrimitive(value) {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\nexport var isIterable = function isIterable(value) {\n  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\n\nexport var AttributeCommitter = /*#__PURE__*/function () {\n  function AttributeCommitter(element, name, strings) {\n    _classCallCheck(this, AttributeCommitter);\n\n    this.dirty = true;\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n\n    for (var i = 0; i < strings.length - 1; i++) {\n      this.parts[i] = this._createPart();\n    }\n  }\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n\n\n  _createClass(AttributeCommitter, [{\n    key: \"_createPart\",\n    value: function _createPart() {\n      return new AttributePart(this);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      var strings = this.strings;\n      var l = strings.length - 1;\n      var text = '';\n\n      for (var i = 0; i < l; i++) {\n        text += strings[i];\n        var part = this.parts[i];\n\n        if (part !== undefined) {\n          var v = part.value;\n\n          if (isPrimitive(v) || !isIterable(v)) {\n            text += typeof v === 'string' ? v : String(v);\n          } else {\n            var _iterator = _createForOfIteratorHelper(v),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var t = _step.value;\n                text += typeof t === 'string' ? t : String(t);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n        }\n      }\n\n      text += strings[l];\n      return text;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.dirty) {\n        this.dirty = false;\n        this.element.setAttribute(this.name, this._getValue());\n      }\n    }\n  }]);\n\n  return AttributeCommitter;\n}();\n/**\n * A Part that controls all or part of an attribute value.\n */\n\nexport var AttributePart = /*#__PURE__*/function () {\n  function AttributePart(committer) {\n    _classCallCheck(this, AttributePart);\n\n    this.value = undefined;\n    this.committer = committer;\n  }\n\n  _createClass(AttributePart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n        this.value = value; // If the value is a not a directive, dirty the committer so that it'll\n        // call setAttribute. If the value is a directive, it'll dirty the\n        // committer if it calls setValue().\n\n        if (!isDirective(value)) {\n          this.committer.dirty = true;\n        }\n      }\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.value)) {\n        var directive = this.value;\n        this.value = noChange;\n        directive(this);\n      }\n\n      if (this.value === noChange) {\n        return;\n      }\n\n      this.committer.commit();\n    }\n  }]);\n\n  return AttributePart;\n}();\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\n\nexport var NodePart = /*#__PURE__*/function () {\n  function NodePart(options) {\n    _classCallCheck(this, NodePart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  _createClass(NodePart, [{\n    key: \"appendInto\",\n    value: function appendInto(container) {\n      this.startNode = container.appendChild(createMarker());\n      this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n\n  }, {\n    key: \"insertAfterNode\",\n    value: function insertAfterNode(ref) {\n      this.startNode = ref;\n      this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n\n  }, {\n    key: \"appendIntoPart\",\n    value: function appendIntoPart(part) {\n      part.__insert(this.startNode = createMarker());\n\n      part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n\n  }, {\n    key: \"insertAfterPart\",\n    value: function insertAfterPart(ref) {\n      ref.__insert(this.startNode = createMarker());\n\n      this.endNode = ref.endNode;\n      ref.endNode = this.startNode;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.startNode.parentNode === null) {\n        return;\n      }\n\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      var value = this.__pendingValue;\n\n      if (value === noChange) {\n        return;\n      }\n\n      if (isPrimitive(value)) {\n        if (value !== this.value) {\n          this.__commitText(value);\n        }\n      } else if (value instanceof TemplateResult) {\n        this.__commitTemplateResult(value);\n      } else if (value instanceof Node) {\n        this.__commitNode(value);\n      } else if (isIterable(value)) {\n        this.__commitIterable(value);\n      } else if (value === nothing) {\n        this.value = nothing;\n        this.clear();\n      } else {\n        // Fallback, will render the string representation\n        this.__commitText(value);\n      }\n    }\n  }, {\n    key: \"__insert\",\n    value: function __insert(node) {\n      this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n  }, {\n    key: \"__commitNode\",\n    value: function __commitNode(value) {\n      if (this.value === value) {\n        return;\n      }\n\n      this.clear();\n\n      this.__insert(value);\n\n      this.value = value;\n    }\n  }, {\n    key: \"__commitText\",\n    value: function __commitText(value) {\n      var node = this.startNode.nextSibling;\n      value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case\n      // it can't be implicitly converted - i.e. it's a symbol.\n\n      var valueAsString = typeof value === 'string' ? value : String(value);\n\n      if (node === this.endNode.previousSibling && node.nodeType === 3\n      /* Node.TEXT_NODE */\n      ) {\n          // If we only have a single text node between the markers, we can just\n          // set its value, rather than replacing it.\n          // TODO(justinfagnani): Can we just check if this.value is primitive?\n          node.data = valueAsString;\n        } else {\n        this.__commitNode(document.createTextNode(valueAsString));\n      }\n\n      this.value = value;\n    }\n  }, {\n    key: \"__commitTemplateResult\",\n    value: function __commitTemplateResult(value) {\n      var template = this.options.templateFactory(value);\n\n      if (this.value instanceof TemplateInstance && this.value.template === template) {\n        this.value.update(value.values);\n      } else {\n        // Make sure we propagate the template processor from the TemplateResult\n        // so that we use its syntax extension, etc. The template factory comes\n        // from the render function options so that it can control template\n        // caching and preprocessing.\n        var instance = new TemplateInstance(template, value.processor, this.options);\n\n        var fragment = instance._clone();\n\n        instance.update(value.values);\n\n        this.__commitNode(fragment);\n\n        this.value = instance;\n      }\n    }\n  }, {\n    key: \"__commitIterable\",\n    value: function __commitIterable(value) {\n      // For an Iterable, we create a new InstancePart per item, then set its\n      // value to the item. This is a little bit of overhead for every item in\n      // an Iterable, but it lets us recurse easily and efficiently update Arrays\n      // of TemplateResults that will be commonly returned from expressions like:\n      // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n      // If _value is an array, then the previous render was of an\n      // iterable and _value will contain the NodeParts from the previous\n      // render. If _value is not an array, clear this part and make a new\n      // array for NodeParts.\n      if (!Array.isArray(this.value)) {\n        this.value = [];\n        this.clear();\n      } // Lets us keep track of how many items we stamped so we can clear leftover\n      // items from a previous render\n\n\n      var itemParts = this.value;\n      var partIndex = 0;\n      var itemPart;\n\n      var _iterator2 = _createForOfIteratorHelper(value),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          // Try to reuse an existing part\n          itemPart = itemParts[partIndex]; // If no existing part, create a new one\n\n          if (itemPart === undefined) {\n            itemPart = new NodePart(this.options);\n            itemParts.push(itemPart);\n\n            if (partIndex === 0) {\n              itemPart.appendIntoPart(this);\n            } else {\n              itemPart.insertAfterPart(itemParts[partIndex - 1]);\n            }\n          }\n\n          itemPart.setValue(item);\n          itemPart.commit();\n          partIndex++;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (partIndex < itemParts.length) {\n        // Truncate the parts array so _value reflects the current state\n        itemParts.length = partIndex;\n        this.clear(itemPart && itemPart.endNode);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;\n      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n  }]);\n\n  return NodePart;\n}();\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\n\nexport var BooleanAttributePart = /*#__PURE__*/function () {\n  function BooleanAttributePart(element, name, strings) {\n    _classCallCheck(this, BooleanAttributePart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error('Boolean attributes can only contain a single expression');\n    }\n\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  _createClass(BooleanAttributePart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      if (this.__pendingValue === noChange) {\n        return;\n      }\n\n      var value = !!this.__pendingValue;\n\n      if (this.value !== value) {\n        if (value) {\n          this.element.setAttribute(this.name, '');\n        } else {\n          this.element.removeAttribute(this.name);\n        }\n\n        this.value = value;\n      }\n\n      this.__pendingValue = noChange;\n    }\n  }]);\n\n  return BooleanAttributePart;\n}();\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\n\nexport var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {\n  _inherits(PropertyCommitter, _AttributeCommitter);\n\n  var _super = _createSuper(PropertyCommitter);\n\n  function PropertyCommitter(element, name, strings) {\n    var _this;\n\n    _classCallCheck(this, PropertyCommitter);\n\n    _this = _super.call(this, element, name, strings);\n    _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';\n    return _this;\n  }\n\n  _createClass(PropertyCommitter, [{\n    key: \"_createPart\",\n    value: function _createPart() {\n      return new PropertyPart(this);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue() {\n      if (this.single) {\n        return this.parts[0].value;\n      }\n\n      return _get(_getPrototypeOf(PropertyCommitter.prototype), \"_getValue\", this).call(this);\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      if (this.dirty) {\n        this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        this.element[this.name] = this._getValue();\n      }\n    }\n  }]);\n\n  return PropertyCommitter;\n}(AttributeCommitter);\nexport var PropertyPart = /*#__PURE__*/function (_AttributePart) {\n  _inherits(PropertyPart, _AttributePart);\n\n  var _super2 = _createSuper(PropertyPart);\n\n  function PropertyPart() {\n    _classCallCheck(this, PropertyPart);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return PropertyPart;\n}(AttributePart); // Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\n\nvar eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n\n(function () {\n  try {\n    var options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.removeEventListener('test', options, options);\n  } catch (_e) {// event options not supported\n  }\n})();\n\nexport var EventPart = /*#__PURE__*/function () {\n  function EventPart(element, eventName, eventContext) {\n    var _this2 = this;\n\n    _classCallCheck(this, EventPart);\n\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n\n    this.__boundHandleEvent = function (e) {\n      return _this2.handleEvent(e);\n    };\n  }\n\n  _createClass(EventPart, [{\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.__pendingValue = value;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      while (isDirective(this.__pendingValue)) {\n        var directive = this.__pendingValue;\n        this.__pendingValue = noChange;\n        directive(this);\n      }\n\n      if (this.__pendingValue === noChange) {\n        return;\n      }\n\n      var newListener = this.__pendingValue;\n      var oldListener = this.value;\n      var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);\n      var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n\n      if (shouldRemoveListener) {\n        this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n      }\n\n      if (shouldAddListener) {\n        this.__options = getOptions(newListener);\n        this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n      }\n\n      this.value = newListener;\n      this.__pendingValue = noChange;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      if (typeof this.value === 'function') {\n        this.value.call(this.eventContext || this.element, event);\n      } else {\n        this.value.handleEvent(event);\n      }\n    }\n  }]);\n\n  return EventPart;\n}(); // We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\n\nvar getOptions = function getOptions(o) {\n  return o && (eventOptionsSupported ? {\n    capture: o.capture,\n    passive: o.passive,\n    once: o.once\n  } : o.capture);\n};","map":{"version":3,"sources":["../src/lib/parts.ts"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;;;;;;;;;AAcA;;;AAIA,SAAQ,WAAR,QAA0B,gBAA1B;AACA,SAAQ,WAAR,QAA0B,UAA1B;AACA,SAAQ,QAAR,EAAkB,OAAlB,QAAsC,WAAtC;AAEA,SAAQ,gBAAR,QAA+B,wBAA/B;AACA,SAAQ,cAAR,QAA6B,sBAA7B;AACA,SAAQ,YAAR,QAA2B,eAA3B;AAIA,OAAO,IAAM,WAAW,GAAG,SAAd,WAAc,CAAC,KAAD,EAAuC;AAChE,SACI,KAAK,KAAK,IAAV,IACA,EAAE,OAAO,KAAP,KAAiB,QAAjB,IAA6B,OAAO,KAAP,KAAiB,UAAhD,CAFJ;AAGD,CAJM;AAKP,OAAO,IAAM,UAAU,GAAG,SAAb,UAAa,CAAC,KAAD,EAA+C;AACvE,SAAO,KAAK,CAAC,OAAN,CAAc,KAAd,KACH;AACA,GAAC,EAAE,KAAK,IAAK,KAAa,CAAC,MAAM,CAAC,QAAR,CAAzB,CAFL;AAGD,CAJM;AAMP;;;;;;AAKA,WAAa,kBAAb;AAOE,8BAAY,OAAZ,EAA8B,IAA9B,EAA4C,OAA5C,EAA0E;AAAA;;AAF1E,SAAA,KAAA,GAAQ,IAAR;AAGE,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,KAAL,GAAa,EAAb;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAAR,GAAiB,CAArC,EAAwC,CAAC,EAAzC,EAA6C;AAC1C,WAAK,KAAL,CAA+B,CAA/B,IAAoC,KAAK,WAAL,EAApC;AACF;AACF;AAED;;;;;AAjBF;AAAA;AAAA,kCAoBuB;AACnB,aAAO,IAAI,aAAJ,CAAkB,IAAlB,CAAP;AACD;AAtBH;AAAA;AAAA,gCAwBqB;AACjB,UAAM,OAAO,GAAG,KAAK,OAArB;AACA,UAAM,CAAC,GAAG,OAAO,CAAC,MAAR,GAAiB,CAA3B;AACA,UAAI,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,QAAA,IAAI,IAAI,OAAO,CAAC,CAAD,CAAf;AACA,YAAM,IAAI,GAAG,KAAK,KAAL,CAAW,CAAX,CAAb;;AACA,YAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,cAAM,CAAC,GAAG,IAAI,CAAC,KAAf;;AACA,cAAI,WAAW,CAAC,CAAD,CAAX,IAAkB,CAAC,UAAU,CAAC,CAAD,CAAjC,EAAsC;AACpC,YAAA,IAAI,IAAI,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAxB,GAA4B,MAAM,CAAC,CAAD,CAA1C;AACD,WAFD,MAEO;AAAA,uDACW,CADX;AAAA;;AAAA;AACL,kEAAmB;AAAA,oBAAR,CAAQ;AACjB,gBAAA,IAAI,IAAI,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAxB,GAA4B,MAAM,CAAC,CAAD,CAA1C;AACD;AAHI;AAAA;AAAA;AAAA;AAAA;AAIN;AACF;AACF;;AAED,MAAA,IAAI,IAAI,OAAO,CAAC,CAAD,CAAf;AACA,aAAO,IAAP;AACD;AA9CH;AAAA;AAAA,6BAgDQ;AACJ,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,KAAL,GAAa,KAAb;AACA,aAAK,OAAL,CAAa,YAAb,CAA0B,KAAK,IAA/B,EAAqC,KAAK,SAAL,EAArC;AACD;AACF;AArDH;;AAAA;AAAA;AAwDA;;;;AAGA,WAAa,aAAb;AAIE,yBAAY,SAAZ,EAAyC;AAAA;;AAFzC,SAAA,KAAA,GAAiB,SAAjB;AAGE,SAAK,SAAL,GAAiB,SAAjB;AACD;;AANH;AAAA;AAAA,6BAQW,KARX,EAQyB;AACrB,UAAI,KAAK,KAAK,QAAV,KAAuB,CAAC,WAAW,CAAC,KAAD,CAAZ,IAAuB,KAAK,KAAK,KAAK,KAA7D,CAAJ,EAAyE;AACvE,aAAK,KAAL,GAAa,KAAb,CADuE,CAEvE;AACA;AACA;;AACA,YAAI,CAAC,WAAW,CAAC,KAAD,CAAhB,EAAyB;AACvB,eAAK,SAAL,CAAe,KAAf,GAAuB,IAAvB;AACD;AACF;AACF;AAlBH;AAAA;AAAA,6BAoBQ;AACJ,aAAO,WAAW,CAAC,KAAK,KAAN,CAAlB,EAAgC;AAC9B,YAAM,SAAS,GAAG,KAAK,KAAvB;AACA,aAAK,KAAL,GAAa,QAAb;AACA,QAAA,SAAS,CAAC,IAAD,CAAT;AACD;;AACD,UAAI,KAAK,KAAL,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AACD,WAAK,SAAL,CAAe,MAAf;AACD;AA9BH;;AAAA;AAAA;AAiCA;;;;;;;;;AAQA,WAAa,QAAb;AAOE,oBAAY,OAAZ,EAAkC;AAAA;;AAHlC,SAAA,KAAA,GAAiB,SAAjB;AACQ,SAAA,cAAA,GAA0B,SAA1B;AAGN,SAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;AAXF;AAAA;AAAA,+BAgBa,SAhBb,EAgB4B;AACxB,WAAK,SAAL,GAAiB,SAAS,CAAC,WAAV,CAAsB,YAAY,EAAlC,CAAjB;AACA,WAAK,OAAL,GAAe,SAAS,CAAC,WAAV,CAAsB,YAAY,EAAlC,CAAf;AACD;AAED;;;;;;;;AArBF;AAAA;AAAA,oCA4BkB,GA5BlB,EA4B2B;AACvB,WAAK,SAAL,GAAiB,GAAjB;AACA,WAAK,OAAL,GAAe,GAAG,CAAC,WAAnB;AACD;AAED;;;;;;AAjCF;AAAA;AAAA,mCAsCiB,IAtCjB,EAsC+B;AAC3B,MAAA,IAAI,CAAC,QAAL,CAAc,KAAK,SAAL,GAAiB,YAAY,EAA3C;;AACA,MAAA,IAAI,CAAC,QAAL,CAAc,KAAK,OAAL,GAAe,YAAY,EAAzC;AACD;AAED;;;;;;AA3CF;AAAA;AAAA,oCAgDkB,GAhDlB,EAgD+B;AAC3B,MAAA,GAAG,CAAC,QAAJ,CAAa,KAAK,SAAL,GAAiB,YAAY,EAA1C;;AACA,WAAK,OAAL,GAAe,GAAG,CAAC,OAAnB;AACA,MAAA,GAAG,CAAC,OAAJ,GAAc,KAAK,SAAnB;AACD;AApDH;AAAA;AAAA,6BAsDW,KAtDX,EAsDyB;AACrB,WAAK,cAAL,GAAsB,KAAtB;AACD;AAxDH;AAAA;AAAA,6BA0DQ;AACJ,UAAI,KAAK,SAAL,CAAe,UAAf,KAA8B,IAAlC,EAAwC;AACtC;AACD;;AACD,aAAO,WAAW,CAAC,KAAK,cAAN,CAAlB,EAAyC;AACvC,YAAM,SAAS,GAAG,KAAK,cAAvB;AACA,aAAK,cAAL,GAAsB,QAAtB;AACA,QAAA,SAAS,CAAC,IAAD,CAAT;AACD;;AACD,UAAM,KAAK,GAAG,KAAK,cAAnB;;AACA,UAAI,KAAK,KAAK,QAAd,EAAwB;AACtB;AACD;;AACD,UAAI,WAAW,CAAC,KAAD,CAAf,EAAwB;AACtB,YAAI,KAAK,KAAK,KAAK,KAAnB,EAA0B;AACxB,eAAK,YAAL,CAAkB,KAAlB;AACD;AACF,OAJD,MAIO,IAAI,KAAK,YAAY,cAArB,EAAqC;AAC1C,aAAK,sBAAL,CAA4B,KAA5B;AACD,OAFM,MAEA,IAAI,KAAK,YAAY,IAArB,EAA2B;AAChC,aAAK,YAAL,CAAkB,KAAlB;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAD,CAAd,EAAuB;AAC5B,aAAK,gBAAL,CAAsB,KAAtB;AACD,OAFM,MAEA,IAAI,KAAK,KAAK,OAAd,EAAuB;AAC5B,aAAK,KAAL,GAAa,OAAb;AACA,aAAK,KAAL;AACD,OAHM,MAGA;AACL;AACA,aAAK,YAAL,CAAkB,KAAlB;AACD;AACF;AAxFH;AAAA;AAAA,6BA0FmB,IA1FnB,EA0F6B;AACzB,WAAK,OAAL,CAAa,UAAb,CAAyB,YAAzB,CAAsC,IAAtC,EAA4C,KAAK,OAAjD;AACD;AA5FH;AAAA;AAAA,iCA8FuB,KA9FvB,EA8FkC;AAC9B,UAAI,KAAK,KAAL,KAAe,KAAnB,EAA0B;AACxB;AACD;;AACD,WAAK,KAAL;;AACA,WAAK,QAAL,CAAc,KAAd;;AACA,WAAK,KAAL,GAAa,KAAb;AACD;AArGH;AAAA;AAAA,iCAuGuB,KAvGvB,EAuGqC;AACjC,UAAM,IAAI,GAAG,KAAK,SAAL,CAAe,WAA5B;AACA,MAAA,KAAK,GAAG,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqB,KAA7B,CAFiC,CAGjC;AACA;;AACA,UAAM,aAAa,GACf,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,MAAM,CAAC,KAAD,CAD9C;;AAEA,UAAI,IAAI,KAAK,KAAK,OAAL,CAAa,eAAtB,IACA,IAAI,CAAC,QAAL,KAAkB;AAAE;AADxB,QAC8C;AAC5C;AACA;AACA;AACC,UAAA,IAAa,CAAC,IAAd,GAAqB,aAArB;AACF,SAND,MAMO;AACL,aAAK,YAAL,CAAkB,QAAQ,CAAC,cAAT,CAAwB,aAAxB,CAAlB;AACD;;AACD,WAAK,KAAL,GAAa,KAAb;AACD;AAxHH;AAAA;AAAA,2CA0HiC,KA1HjC,EA0HsD;AAClD,UAAM,QAAQ,GAAG,KAAK,OAAL,CAAa,eAAb,CAA6B,KAA7B,CAAjB;;AACA,UAAI,KAAK,KAAL,YAAsB,gBAAtB,IACA,KAAK,KAAL,CAAW,QAAX,KAAwB,QAD5B,EACsC;AACpC,aAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,CAAC,MAAxB;AACD,OAHD,MAGO;AACL;AACA;AACA;AACA;AACA,YAAM,QAAQ,GACV,IAAI,gBAAJ,CAAqB,QAArB,EAA+B,KAAK,CAAC,SAArC,EAAgD,KAAK,OAArD,CADJ;;AAEA,YAAM,QAAQ,GAAG,QAAQ,CAAC,MAAT,EAAjB;;AACA,QAAA,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAAC,MAAtB;;AACA,aAAK,YAAL,CAAkB,QAAlB;;AACA,aAAK,KAAL,GAAa,QAAb;AACD;AACF;AA3IH;AAAA;AAAA,qCA6I2B,KA7I3B,EA6ImD;AAC/C;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAK,KAAnB,CAAL,EAAgC;AAC9B,aAAK,KAAL,GAAa,EAAb;AACA,aAAK,KAAL;AACD,OAd8C,CAgB/C;AACA;;;AACA,UAAM,SAAS,GAAG,KAAK,KAAvB;AACA,UAAI,SAAS,GAAG,CAAhB;AACA,UAAI,QAAJ;;AApB+C,kDAsB5B,KAtB4B;AAAA;;AAAA;AAsB/C,+DAA0B;AAAA,cAAf,IAAe;AACxB;AACA,UAAA,QAAQ,GAAG,SAAS,CAAC,SAAD,CAApB,CAFwB,CAIxB;;AACA,cAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,YAAA,QAAQ,GAAG,IAAI,QAAJ,CAAa,KAAK,OAAlB,CAAX;AACA,YAAA,SAAS,CAAC,IAAV,CAAe,QAAf;;AACA,gBAAI,SAAS,KAAK,CAAlB,EAAqB;AACnB,cAAA,QAAQ,CAAC,cAAT,CAAwB,IAAxB;AACD,aAFD,MAEO;AACL,cAAA,QAAQ,CAAC,eAAT,CAAyB,SAAS,CAAC,SAAS,GAAG,CAAb,CAAlC;AACD;AACF;;AACD,UAAA,QAAQ,CAAC,QAAT,CAAkB,IAAlB;AACA,UAAA,QAAQ,CAAC,MAAT;AACA,UAAA,SAAS;AACV;AAvC8C;AAAA;AAAA;AAAA;AAAA;;AAyC/C,UAAI,SAAS,GAAG,SAAS,CAAC,MAA1B,EAAkC;AAChC;AACA,QAAA,SAAS,CAAC,MAAV,GAAmB,SAAnB;AACA,aAAK,KAAL,CAAW,QAAQ,IAAI,QAAQ,CAAC,OAAhC;AACD;AACF;AA3LH;AAAA;AAAA,4BA6LwC;AAAA,UAAhC,SAAgC,uEAAd,KAAK,SAAS;AACpC,MAAA,WAAW,CACP,KAAK,SAAL,CAAe,UADR,EACqB,SAAS,CAAC,WAD/B,EAC6C,KAAK,OADlD,CAAX;AAED;AAhMH;;AAAA;AAAA;AAmMA;;;;;;;;AAOA,WAAa,oBAAb;AAOE,gCAAY,OAAZ,EAA8B,IAA9B,EAA4C,OAA5C,EAAsE;AAAA;;AAHtE,SAAA,KAAA,GAAiB,SAAjB;AACQ,SAAA,cAAA,GAA0B,SAA1B;;AAGN,QAAI,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,OAAO,CAAC,CAAD,CAAP,KAAe,EAAvC,IAA6C,OAAO,CAAC,CAAD,CAAP,KAAe,EAAhE,EAAoE;AAClE,YAAM,IAAI,KAAJ,CACF,yDADE,CAAN;AAED;;AACD,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,OAAL,GAAe,OAAf;AACD;;AAfH;AAAA;AAAA,6BAiBW,KAjBX,EAiByB;AACrB,WAAK,cAAL,GAAsB,KAAtB;AACD;AAnBH;AAAA;AAAA,6BAqBQ;AACJ,aAAO,WAAW,CAAC,KAAK,cAAN,CAAlB,EAAyC;AACvC,YAAM,SAAS,GAAG,KAAK,cAAvB;AACA,aAAK,cAAL,GAAsB,QAAtB;AACA,QAAA,SAAS,CAAC,IAAD,CAAT;AACD;;AACD,UAAI,KAAK,cAAL,KAAwB,QAA5B,EAAsC;AACpC;AACD;;AACD,UAAM,KAAK,GAAG,CAAC,CAAC,KAAK,cAArB;;AACA,UAAI,KAAK,KAAL,KAAe,KAAnB,EAA0B;AACxB,YAAI,KAAJ,EAAW;AACT,eAAK,OAAL,CAAa,YAAb,CAA0B,KAAK,IAA/B,EAAqC,EAArC;AACD,SAFD,MAEO;AACL,eAAK,OAAL,CAAa,eAAb,CAA6B,KAAK,IAAlC;AACD;;AACD,aAAK,KAAL,GAAa,KAAb;AACD;;AACD,WAAK,cAAL,GAAsB,QAAtB;AACD;AAxCH;;AAAA;AAAA;AA2CA;;;;;;;;;;AASA,WAAa,iBAAb;AAAA;;AAAA;;AAGE,6BAAY,OAAZ,EAA8B,IAA9B,EAA4C,OAA5C,EAA0E;AAAA;;AAAA;;AACxE,8BAAM,OAAN,EAAe,IAAf,EAAqB,OAArB;AACA,UAAK,MAAL,GACK,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,OAAO,CAAC,CAAD,CAAP,KAAe,EAAvC,IAA6C,OAAO,CAAC,CAAD,CAAP,KAAe,EADjE;AAFwE;AAIzE;;AAPH;AAAA;AAAA,kCASuB;AACnB,aAAO,IAAI,YAAJ,CAAiB,IAAjB,CAAP;AACD;AAXH;AAAA;AAAA,gCAaqB;AACjB,UAAI,KAAK,MAAT,EAAiB;AACf,eAAO,KAAK,KAAL,CAAW,CAAX,EAAc,KAArB;AACD;;AACD;AACD;AAlBH;AAAA;AAAA,6BAoBQ;AACJ,UAAI,KAAK,KAAT,EAAgB;AACd,aAAK,KAAL,GAAa,KAAb,CADc,CAEd;;AACC,aAAK,OAAL,CAAqB,KAAK,IAA1B,IAAkC,KAAK,SAAL,EAAlC;AACF;AACF;AA1BH;;AAAA;AAAA,EAAuC,kBAAvC;AA6BA,WAAa,YAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,EAAkC,aAAlC,E,CAEA;AACA;AACA;AACA;;AACA,IAAI,qBAAqB,GAAG,KAA5B,C,CAEA;AACA;;AACA,CAAC,YAAK;AACJ,MAAI;AACF,QAAM,OAAO,GAAG;AACd,UAAI,OAAJ,GAAW;AACT,QAAA,qBAAqB,GAAG,IAAxB;AACA,eAAO,KAAP;AACD;;AAJa,KAAhB,CADE,CAOF;;AACA,IAAA,MAAM,CAAC,gBAAP,CAAwB,MAAxB,EAAgC,OAAhC,EAAgD,OAAhD,EARE,CASF;;AACA,IAAA,MAAM,CAAC,mBAAP,CAA2B,MAA3B,EAAmC,OAAnC,EAAmD,OAAnD;AACD,GAXD,CAWE,OAAO,EAAP,EAAW,CACX;AACD;AACF,CAfD;;AAmBA,WAAa,SAAb;AASE,qBAAY,OAAZ,EAA8B,SAA9B,EAAiD,YAAjD,EAA2E;AAAA;;AAAA;;AAL3E,SAAA,KAAA,GAA2C,SAA3C;AAEQ,SAAA,cAAA,GAAoD,SAApD;AAIN,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,YAAL,GAAoB,YAApB;;AACA,SAAK,kBAAL,GAA0B,UAAC,CAAD;AAAA,aAAO,MAAI,CAAC,WAAL,CAAiB,CAAjB,CAAP;AAAA,KAA1B;AACD;;AAdH;AAAA;AAAA,6BAgBW,KAhBX,EAgBmD;AAC/C,WAAK,cAAL,GAAsB,KAAtB;AACD;AAlBH;AAAA;AAAA,6BAoBQ;AACJ,aAAO,WAAW,CAAC,KAAK,cAAN,CAAlB,EAAyC;AACvC,YAAM,SAAS,GAAG,KAAK,cAAvB;AACA,aAAK,cAAL,GAAsB,QAAtB;AACA,QAAA,SAAS,CAAC,IAAD,CAAT;AACD;;AACD,UAAI,KAAK,cAAL,KAAwB,QAA5B,EAAsC;AACpC;AACD;;AAED,UAAM,WAAW,GAAG,KAAK,cAAzB;AACA,UAAM,WAAW,GAAG,KAAK,KAAzB;AACA,UAAM,oBAAoB,GAAG,WAAW,IAAI,IAAf,IACzB,WAAW,IAAI,IAAf,KACK,WAAW,CAAC,OAAZ,KAAwB,WAAW,CAAC,OAApC,IACA,WAAW,CAAC,IAAZ,KAAqB,WAAW,CAAC,IADjC,IAEA,WAAW,CAAC,OAAZ,KAAwB,WAAW,CAAC,OAHzC,CADJ;AAKA,UAAM,iBAAiB,GACnB,WAAW,IAAI,IAAf,KAAwB,WAAW,IAAI,IAAf,IAAuB,oBAA/C,CADJ;;AAGA,UAAI,oBAAJ,EAA0B;AACxB,aAAK,OAAL,CAAa,mBAAb,CACI,KAAK,SADT,EACoB,KAAK,kBADzB,EAC6C,KAAK,SADlD;AAED;;AACD,UAAI,iBAAJ,EAAuB;AACrB,aAAK,SAAL,GAAiB,UAAU,CAAC,WAAD,CAA3B;AACA,aAAK,OAAL,CAAa,gBAAb,CACI,KAAK,SADT,EACoB,KAAK,kBADzB,EAC6C,KAAK,SADlD;AAED;;AACD,WAAK,KAAL,GAAa,WAAb;AACA,WAAK,cAAL,GAAsB,QAAtB;AACD;AAnDH;AAAA;AAAA,gCAqDc,KArDd,EAqD0B;AACtB,UAAI,OAAO,KAAK,KAAZ,KAAsB,UAA1B,EAAsC;AACpC,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,YAAL,IAAqB,KAAK,OAA1C,EAAmD,KAAnD;AACD,OAFD,MAEO;AACJ,aAAK,KAAL,CAAmC,WAAnC,CAA+C,KAA/C;AACF;AACF;AA3DH;;AAAA;AAAA,I,CA8DA;AACA;AACA;;AACA,IAAM,UAAU,GAAG,SAAb,UAAa,CAAC,CAAD;AAAA,SAA0C,CAAC,KACzD,qBAAqB,GACjB;AAAC,IAAA,OAAO,EAAE,CAAC,CAAC,OAAZ;AAAqB,IAAA,OAAO,EAAE,CAAC,CAAC,OAAhC;AAAyC,IAAA,IAAI,EAAE,CAAC,CAAC;AAAjD,GADiB,GAEjB,CAAC,CAAC,OAHmD,CAA3C;AAAA,CAAnB","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\nimport {isDirective} from './directive.js';\nimport {removeNodes} from './dom.js';\nimport {noChange, nothing, Part} from './part.js';\nimport {RenderOptions} from './render-options.js';\nimport {TemplateInstance} from './template-instance.js';\nimport {TemplateResult} from './template-result.js';\nimport {createMarker} from './template.js';\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\nexport type Primitive = null|undefined|boolean|number|string|symbol|bigint;\nexport const isPrimitive = (value: unknown): value is Primitive => {\n  return (\n      value === null ||\n      !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value: unknown): value is Iterable<unknown> => {\n  return Array.isArray(value) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      !!(value && (value as any)[Symbol.iterator]);\n};\n\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: ReadonlyArray<string>;\n  readonly parts: ReadonlyArray<AttributePart>;\n  dirty = true;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n    this.parts = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      (this.parts as AttributePart[])[i] = this._createPart();\n    }\n  }\n\n  /**\n   * Creates a single part. Override this to create a differnt type of part.\n   */\n  protected _createPart(): AttributePart {\n    return new AttributePart(this);\n  }\n\n  protected _getValue(): unknown {\n    const strings = this.strings;\n    const l = strings.length - 1;\n    let text = '';\n\n    for (let i = 0; i < l; i++) {\n      text += strings[i];\n      const part = this.parts[i];\n      if (part !== undefined) {\n        const v = part.value;\n        if (isPrimitive(v) || !isIterable(v)) {\n          text += typeof v === 'string' ? v : String(v);\n        } else {\n          for (const t of v) {\n            text += typeof t === 'string' ? t : String(t);\n          }\n        }\n      }\n    }\n\n    text += strings[l];\n    return text;\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      this.element.setAttribute(this.name, this._getValue() as string);\n    }\n  }\n}\n\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart implements Part {\n  readonly committer: AttributeCommitter;\n  value: unknown = undefined;\n\n  constructor(committer: AttributeCommitter) {\n    this.committer = committer;\n  }\n\n  setValue(value: unknown): void {\n    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n      this.value = value;\n      // If the value is a not a directive, dirty the committer so that it'll\n      // call setAttribute. If the value is a directive, it'll dirty the\n      // committer if it calls setValue().\n      if (!isDirective(value)) {\n        this.committer.dirty = true;\n      }\n    }\n  }\n\n  commit() {\n    while (isDirective(this.value)) {\n      const directive = this.value;\n      this.value = noChange;\n      directive(this);\n    }\n    if (this.value === noChange) {\n      return;\n    }\n    this.committer.commit();\n  }\n}\n\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart implements Part {\n  readonly options: RenderOptions;\n  startNode!: Node;\n  endNode!: Node;\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(options: RenderOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendInto(container: Node) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterNode(ref: Node) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling!;\n  }\n\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  appendIntoPart(part: NodePart) {\n    part.__insert(this.startNode = createMarker());\n    part.__insert(this.endNode = createMarker());\n  }\n\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n  insertAfterPart(ref: NodePart) {\n    ref.__insert(this.startNode = createMarker());\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    const value = this.__pendingValue;\n    if (value === noChange) {\n      return;\n    }\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n\n  private __insert(node: Node) {\n    this.endNode.parentNode!.insertBefore(node, this.endNode);\n  }\n\n  private __commitNode(value: Node): void {\n    if (this.value === value) {\n      return;\n    }\n    this.clear();\n    this.__insert(value);\n    this.value = value;\n  }\n\n  private __commitText(value: unknown): void {\n    const node = this.startNode.nextSibling!;\n    value = value == null ? '' : value;\n    // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n    const valueAsString: string =\n        typeof value === 'string' ? value : String(value);\n    if (node === this.endNode.previousSibling &&\n        node.nodeType === 3 /* Node.TEXT_NODE */) {\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      // TODO(justinfagnani): Can we just check if this.value is primitive?\n      (node as Text).data = valueAsString;\n    } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n    this.value = value;\n  }\n\n  private __commitTemplateResult(value: TemplateResult): void {\n    const template = this.options.templateFactory(value);\n    if (this.value instanceof TemplateInstance &&\n        this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance =\n          new TemplateInstance(template, value.processor, this.options);\n      const fragment = instance._clone();\n      instance.update(value.values);\n      this.__commitNode(fragment);\n      this.value = instance;\n    }\n  }\n\n  private __commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this.value as NodePart[];\n    let partIndex = 0;\n    let itemPart: NodePart|undefined;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex];\n\n      // If no existing part, create a new one\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n\n  clear(startNode: Node = this.startNode) {\n    removeNodes(\n        this.startNode.parentNode!, startNode.nextSibling!, this.endNode);\n  }\n}\n\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart implements Part {\n  readonly element: Element;\n  readonly name: string;\n  readonly strings: readonly string[];\n  value: unknown = undefined;\n  private __pendingValue: unknown = undefined;\n\n  constructor(element: Element, name: string, strings: readonly string[]) {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n      throw new Error(\n          'Boolean attributes can only contain a single expression');\n    }\n    this.element = element;\n    this.name = name;\n    this.strings = strings;\n  }\n\n  setValue(value: unknown): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n    const value = !!this.__pendingValue;\n    if (this.value !== value) {\n      if (value) {\n        this.element.setAttribute(this.name, '');\n      } else {\n        this.element.removeAttribute(this.name);\n      }\n      this.value = value;\n    }\n    this.__pendingValue = noChange;\n  }\n}\n\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n  readonly single: boolean;\n\n  constructor(element: Element, name: string, strings: ReadonlyArray<string>) {\n    super(element, name, strings);\n    this.single =\n        (strings.length === 2 && strings[0] === '' && strings[1] === '');\n  }\n\n  protected _createPart(): PropertyPart {\n    return new PropertyPart(this);\n  }\n\n  protected _getValue() {\n    if (this.single) {\n      return this.parts[0].value;\n    }\n    return super._getValue();\n  }\n\n  commit(): void {\n    if (this.dirty) {\n      this.dirty = false;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.element as any)[this.name] = this._getValue();\n    }\n  }\n}\n\nexport class PropertyPart extends AttributePart {}\n\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.addEventListener('test', options as any, options);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    window.removeEventListener('test', options as any, options);\n  } catch (_e) {\n    // event options not supported\n  }\n})();\n\ntype EventHandlerWithOptions =\n    EventListenerOrEventListenerObject&Partial<AddEventListenerOptions>;\nexport class EventPart implements Part {\n  readonly element: Element;\n  readonly eventName: string;\n  readonly eventContext?: EventTarget;\n  value: undefined|EventHandlerWithOptions = undefined;\n  private __options?: AddEventListenerOptions;\n  private __pendingValue: undefined|EventHandlerWithOptions = undefined;\n  private readonly __boundHandleEvent: (event: Event) => void;\n\n  constructor(element: Element, eventName: string, eventContext?: EventTarget) {\n    this.element = element;\n    this.eventName = eventName;\n    this.eventContext = eventContext;\n    this.__boundHandleEvent = (e) => this.handleEvent(e);\n  }\n\n  setValue(value: undefined|EventHandlerWithOptions): void {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange as EventHandlerWithOptions;\n      directive(this);\n    }\n    if (this.__pendingValue === noChange) {\n      return;\n    }\n\n    const newListener = this.__pendingValue;\n    const oldListener = this.value;\n    const shouldRemoveListener = newListener == null ||\n        oldListener != null &&\n            (newListener.capture !== oldListener.capture ||\n             newListener.once !== oldListener.once ||\n             newListener.passive !== oldListener.passive);\n    const shouldAddListener =\n        newListener != null && (oldListener == null || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    if (shouldAddListener) {\n      this.__options = getOptions(newListener);\n      this.element.addEventListener(\n          this.eventName, this.__boundHandleEvent, this.__options);\n    }\n    this.value = newListener;\n    this.__pendingValue = noChange as EventHandlerWithOptions;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this.value === 'function') {\n      this.value.call(this.eventContext || this.element, event);\n    } else {\n      (this.value as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o: AddEventListenerOptions|undefined) => o &&\n    (eventOptionsSupported ?\n         {capture: o.capture, passive: o.passive, once: o.once} :\n         o.capture as AddEventListenerOptions);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}