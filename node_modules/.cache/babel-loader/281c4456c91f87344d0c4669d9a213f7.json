{"ast":null,"code":"import _regeneratorRuntime from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\nvar MAX_RERENDER_COUNT = 10; // Tells whether a render task is currently scheduled\n\nvar renderTaskId; // Queue for invalidated web components\n\nvar invalidatedWebComponents = new RenderQueue();\nvar renderTaskPromise, renderTaskPromiseResolve, taskResult;\nvar mutationObserverTimer;\n/**\n * Class that manages the rendering/re-rendering of web components\n * This is always asynchronous\n */\n\nvar RenderScheduler = /*#__PURE__*/function () {\n  function RenderScheduler() {\n    _classCallCheck(this, RenderScheduler);\n\n    throw new Error(\"Static class\");\n  }\n  /**\n   * Queues a web component for re-rendering\n   * @param webComponent\n   */\n\n\n  _createClass(RenderScheduler, null, [{\n    key: \"renderDeferred\",\n    value: function renderDeferred(webComponent) {\n      // Enqueue the web component\n      var res = invalidatedWebComponents.add(webComponent); // Schedule a rendering task\n\n      RenderScheduler.scheduleRenderTask();\n      return res;\n    }\n  }, {\n    key: \"renderImmediately\",\n    value: function renderImmediately(webComponent) {\n      // Enqueue the web component\n      var res = invalidatedWebComponents.add(webComponent); // Immediately start a render task\n\n      RenderScheduler.runRenderTask();\n      return res;\n    }\n    /**\n     * Schedules a rendering task, if not scheduled already\n     */\n\n  }, {\n    key: \"scheduleRenderTask\",\n    value: function scheduleRenderTask() {\n      if (!renderTaskId) {\n        // renderTaskId = window.setTimeout(RenderScheduler.renderWebComponents, 3000); // Task\n        // renderTaskId = Promise.resolve().then(RenderScheduler.renderWebComponents); // Micro task\n        renderTaskId = window.requestAnimationFrame(RenderScheduler.renderWebComponents); // AF\n      }\n    }\n  }, {\n    key: \"runRenderTask\",\n    value: function runRenderTask() {\n      if (!renderTaskId) {\n        renderTaskId = 1; // prevent another rendering task from being scheduled, all web components should use this task\n\n        RenderScheduler.renderWebComponents();\n      }\n    }\n  }, {\n    key: \"renderWebComponents\",\n    value: function renderWebComponents() {\n      // console.log(\"------------- NEW RENDER TASK ---------------\");\n      var webComponentInfo, webComponent, promise;\n      var renderStats = new Map();\n\n      while (webComponentInfo = invalidatedWebComponents.shift()) {\n        // eslint-disable-line\n        webComponent = webComponentInfo.webComponent;\n        promise = webComponentInfo.promise;\n        var timesRerendered = renderStats.get(webComponent) || 0;\n\n        if (timesRerendered > MAX_RERENDER_COUNT) {\n          // console.warn(\"WARNING RERENDER\", webComponent);\n          throw new Error(\"Web component re-rendered too many times this task, max allowed is: \".concat(MAX_RERENDER_COUNT));\n        }\n\n        webComponent._render();\n\n        promise._deferredResolve();\n\n        renderStats.set(webComponent, timesRerendered + 1);\n      } // wait for Mutation observer just in case\n\n\n      if (!mutationObserverTimer) {\n        mutationObserverTimer = setTimeout(function () {\n          mutationObserverTimer = undefined;\n\n          if (invalidatedWebComponents.getList().length === 0) {\n            RenderScheduler._resolveTaskPromise();\n          }\n        }, 200);\n      }\n\n      renderTaskId = undefined;\n    }\n    /**\n     * return a promise that will be resolved once all invalidated web components are rendered\n     */\n\n  }, {\n    key: \"whenDOMUpdated\",\n    value: function whenDOMUpdated() {\n      if (renderTaskPromise) {\n        return renderTaskPromise;\n      }\n\n      renderTaskPromise = new Promise(function (resolve) {\n        renderTaskPromiseResolve = resolve;\n        window.requestAnimationFrame(function () {\n          if (invalidatedWebComponents.getList().length === 0) {\n            renderTaskPromise = undefined;\n            resolve();\n          }\n        });\n      });\n      return renderTaskPromise;\n    }\n  }, {\n    key: \"whenAllCustomElementsAreDefined\",\n    value: function whenAllCustomElementsAreDefined() {\n      var definedPromises = getAllRegisteredTags().map(function (tag) {\n        return customElements.whenDefined(tag);\n      });\n      return Promise.all(definedPromises);\n    }\n  }, {\n    key: \"whenFinished\",\n    value: function () {\n      var _whenFinished = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return RenderScheduler.whenAllCustomElementsAreDefined();\n\n              case 2:\n                _context.next = 4;\n                return RenderScheduler.whenDOMUpdated();\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function whenFinished() {\n        return _whenFinished.apply(this, arguments);\n      }\n\n      return whenFinished;\n    }()\n  }, {\n    key: \"_resolveTaskPromise\",\n    value: function _resolveTaskPromise() {\n      if (invalidatedWebComponents.getList().length > 0) {\n        // More updates are pending. Resolve will be called again\n        return;\n      }\n\n      if (renderTaskPromiseResolve) {\n        renderTaskPromiseResolve.call(this, taskResult);\n        renderTaskPromiseResolve = undefined;\n        renderTaskPromise = undefined;\n      }\n    }\n  }]);\n\n  return RenderScheduler;\n}();\n\nexport default RenderScheduler;","map":{"version":3,"sources":["/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/@ui5/webcomponents-base/dist/RenderScheduler.js"],"names":["RenderQueue","getAllRegisteredTags","MAX_RERENDER_COUNT","renderTaskId","invalidatedWebComponents","renderTaskPromise","renderTaskPromiseResolve","taskResult","mutationObserverTimer","RenderScheduler","Error","webComponent","res","add","scheduleRenderTask","runRenderTask","window","requestAnimationFrame","renderWebComponents","webComponentInfo","promise","renderStats","Map","shift","timesRerendered","get","_render","_deferredResolve","set","setTimeout","undefined","getList","length","_resolveTaskPromise","Promise","resolve","definedPromises","map","tag","customElements","whenDefined","all","whenAllCustomElementsAreDefined","whenDOMUpdated","call"],"mappings":"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","sourcesContent":["import RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\n\nconst MAX_RERENDER_COUNT = 10;\n\n// Tells whether a render task is currently scheduled\nlet renderTaskId;\n\n// Queue for invalidated web components\nconst invalidatedWebComponents = new RenderQueue();\n\nlet renderTaskPromise,\n\trenderTaskPromiseResolve,\n\ttaskResult;\n\nlet mutationObserverTimer;\n\n/**\n * Class that manages the rendering/re-rendering of web components\n * This is always asynchronous\n */\nclass RenderScheduler {\n\tconstructor() {\n\t\tthrow new Error(\"Static class\");\n\t}\n\n\t/**\n\t * Queues a web component for re-rendering\n\t * @param webComponent\n\t */\n\tstatic renderDeferred(webComponent) {\n\t\t// Enqueue the web component\n\t\tconst res = invalidatedWebComponents.add(webComponent);\n\n\t\t// Schedule a rendering task\n\t\tRenderScheduler.scheduleRenderTask();\n\t\treturn res;\n\t}\n\n\tstatic renderImmediately(webComponent) {\n\t\t// Enqueue the web component\n\t\tconst res = invalidatedWebComponents.add(webComponent);\n\n\t\t// Immediately start a render task\n\t\tRenderScheduler.runRenderTask();\n\t\treturn res;\n\t}\n\n\t/**\n\t * Schedules a rendering task, if not scheduled already\n\t */\n\tstatic scheduleRenderTask() {\n\t\tif (!renderTaskId) {\n\t\t\t// renderTaskId = window.setTimeout(RenderScheduler.renderWebComponents, 3000); // Task\n\t\t\t// renderTaskId = Promise.resolve().then(RenderScheduler.renderWebComponents); // Micro task\n\t\t\trenderTaskId = window.requestAnimationFrame(RenderScheduler.renderWebComponents); // AF\n\t\t}\n\t}\n\n\tstatic runRenderTask() {\n\t\tif (!renderTaskId) {\n\t\t\trenderTaskId = 1; // prevent another rendering task from being scheduled, all web components should use this task\n\t\t\tRenderScheduler.renderWebComponents();\n\t\t}\n\t}\n\n\tstatic renderWebComponents() {\n\t\t// console.log(\"------------- NEW RENDER TASK ---------------\");\n\n\t\tlet webComponentInfo,\n\t\t\twebComponent,\n\t\t\tpromise;\n\t\tconst renderStats = new Map();\n\t\twhile (webComponentInfo = invalidatedWebComponents.shift()) { // eslint-disable-line\n\t\t\twebComponent = webComponentInfo.webComponent;\n\t\t\tpromise = webComponentInfo.promise;\n\n\t\t\tconst timesRerendered = renderStats.get(webComponent) || 0;\n\t\t\tif (timesRerendered > MAX_RERENDER_COUNT) {\n\t\t\t\t// console.warn(\"WARNING RERENDER\", webComponent);\n\t\t\t\tthrow new Error(`Web component re-rendered too many times this task, max allowed is: ${MAX_RERENDER_COUNT}`);\n\t\t\t}\n\t\t\twebComponent._render();\n\t\t\tpromise._deferredResolve();\n\t\t\trenderStats.set(webComponent, timesRerendered + 1);\n\t\t}\n\n\t\t// wait for Mutation observer just in case\n\t\tif (!mutationObserverTimer) {\n\t\t\tmutationObserverTimer = setTimeout(() => {\n\t\t\t\tmutationObserverTimer = undefined;\n\t\t\t\tif (invalidatedWebComponents.getList().length === 0) {\n\t\t\t\t\tRenderScheduler._resolveTaskPromise();\n\t\t\t\t}\n\t\t\t}, 200);\n\t\t}\n\n\t\trenderTaskId = undefined;\n\t}\n\n\t/**\n\t * return a promise that will be resolved once all invalidated web components are rendered\n\t */\n\tstatic whenDOMUpdated() {\n\t\tif (renderTaskPromise) {\n\t\t\treturn renderTaskPromise;\n\t\t}\n\n\t\trenderTaskPromise = new Promise(resolve => {\n\t\t\trenderTaskPromiseResolve = resolve;\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\tif (invalidatedWebComponents.getList().length === 0) {\n\t\t\t\t\trenderTaskPromise = undefined;\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn renderTaskPromise;\n\t}\n\n\tstatic whenAllCustomElementsAreDefined() {\n\t\tconst definedPromises = getAllRegisteredTags().map(tag => customElements.whenDefined(tag));\n\t\treturn Promise.all(definedPromises);\n\t}\n\n\tstatic async whenFinished() {\n\t\tawait RenderScheduler.whenAllCustomElementsAreDefined();\n\t\tawait RenderScheduler.whenDOMUpdated();\n\t}\n\n\tstatic _resolveTaskPromise() {\n\t\tif (invalidatedWebComponents.getList().length > 0) {\n\t\t\t// More updates are pending. Resolve will be called again\n\t\t\treturn;\n\t\t}\n\n\t\tif (renderTaskPromiseResolve) {\n\t\t\trenderTaskPromiseResolve.call(this, taskResult);\n\t\t\trenderTaskPromiseResolve = undefined;\n\t\t\trenderTaskPromise = undefined;\n\t\t}\n\t}\n}\n\nexport default RenderScheduler;\n"]},"metadata":{},"sourceType":"module"}