{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { createMarker, directive, NodePart, removeNodes, reparentNodes } from '../lit-html.js'; // Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\n\nconst createAndInsertPart = (containerPart, beforePart) => {\n  const container = containerPart.startNode.parentNode;\n  const beforeNode = beforePart === undefined ? containerPart.endNode : beforePart.startNode;\n  const startNode = container.insertBefore(createMarker(), beforeNode);\n  container.insertBefore(createMarker(), beforeNode);\n  const newPart = new NodePart(containerPart.options);\n  newPart.insertAfterNode(startNode);\n  return newPart;\n};\n\nconst updatePart = (part, value) => {\n  part.setValue(value);\n  part.commit();\n  return part;\n};\n\nconst insertPartBefore = (containerPart, part, ref) => {\n  const container = containerPart.startNode.parentNode;\n  const beforeNode = ref ? ref.startNode : containerPart.endNode;\n  const endNode = part.endNode.nextSibling;\n\n  if (endNode !== beforeNode) {\n    reparentNodes(container, part.startNode, endNode, beforeNode);\n  }\n};\n\nconst removePart = part => {\n  removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);\n}; // Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\n\n\nconst generateMap = (list, start, end) => {\n  const map = new Map();\n\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n\n  return map;\n}; // Stores previous ordered list of parts and map of key to index\n\n\nconst partListCache = new WeakMap();\nconst keyListCache = new WeakMap();\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\n\nexport const repeat = directive((items, keyFnOrTemplate, template) => {\n  let keyFn;\n\n  if (template === undefined) {\n    template = keyFnOrTemplate;\n  } else if (keyFnOrTemplate !== undefined) {\n    keyFn = keyFnOrTemplate;\n  }\n\n  return containerPart => {\n    if (!(containerPart instanceof NodePart)) {\n      throw new Error('repeat can only be used in text bindings');\n    } // Old part & key lists are retrieved from the last update\n    // (associated with the part for this instance of the directive)\n\n\n    const oldParts = partListCache.get(containerPart) || [];\n    const oldKeys = keyListCache.get(containerPart) || []; // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n\n    const newParts = []; // New value list is eagerly generated from items along with a\n    // parallel array indicating its key.\n\n    const newValues = [];\n    const newKeys = [];\n    let index = 0;\n\n    for (const item of items) {\n      newKeys[index] = keyFn ? keyFn(item, index) : index;\n      newValues[index] = template(item, index);\n      index++;\n    } // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n\n\n    let newKeyToIndexMap;\n    let oldKeyToIndexMap; // Head and tail pointers to old parts and new values\n\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1; // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * TODO(kschaaf) Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);\n        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);\n        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);\n            updatePart(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = updatePart(oldPart, newValues[newHead]);\n            insertPartBefore(containerPart, oldPart, oldParts[oldHead]); // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n\n            oldParts[oldIndex] = null;\n          }\n\n          newHead++;\n        }\n      }\n    } // Add parts for any remaining new values\n\n\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);\n      updatePart(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    } // Remove any remaining unused old parts\n\n\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    } // Save order of new parts for next round\n\n\n    partListCache.set(containerPart, newParts);\n    keyListCache.set(containerPart, newKeys);\n  };\n});","map":{"version":3,"sources":["../src/directives/repeat.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;AAeA,SAAQ,YAAR,EAAsB,SAAtB,EAAiC,QAAjC,EAAiD,WAAjD,EAA8D,aAA9D,QAAkF,gBAAlF,C,CAKA;AACA;;AACA,MAAM,mBAAmB,GACrB,CAAC,aAAD,EAA0B,UAA1B,KAA6D;AAC3D,QAAM,SAAS,GAAG,aAAa,CAAC,SAAd,CAAwB,UAA1C;AACA,QAAM,UAAU,GAAG,UAAU,KAAK,SAAf,GAA2B,aAAa,CAAC,OAAzC,GAC2B,UAAU,CAAC,SADzD;AAEA,QAAM,SAAS,GAAG,SAAS,CAAC,YAAV,CAAuB,YAAY,EAAnC,EAAuC,UAAvC,CAAlB;AACA,EAAA,SAAS,CAAC,YAAV,CAAuB,YAAY,EAAnC,EAAuC,UAAvC;AACA,QAAM,OAAO,GAAG,IAAI,QAAJ,CAAa,aAAa,CAAC,OAA3B,CAAhB;AACA,EAAA,OAAO,CAAC,eAAR,CAAwB,SAAxB;AACA,SAAO,OAAP;AACD,CAVL;;AAYA,MAAM,UAAU,GAAG,CAAC,IAAD,EAAiB,KAAjB,KAAmC;AACpD,EAAA,IAAI,CAAC,QAAL,CAAc,KAAd;AACA,EAAA,IAAI,CAAC,MAAL;AACA,SAAO,IAAP;AACD,CAJD;;AAMA,MAAM,gBAAgB,GAClB,CAAC,aAAD,EAA0B,IAA1B,EAA0C,GAA1C,KAA4D;AAC1D,QAAM,SAAS,GAAG,aAAa,CAAC,SAAd,CAAwB,UAA1C;AACA,QAAM,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC,SAAP,GAAmB,aAAa,CAAC,OAAvD;AACA,QAAM,OAAO,GAAG,IAAI,CAAC,OAAL,CAAa,WAA7B;;AACA,MAAI,OAAO,KAAK,UAAhB,EAA4B;AAC1B,IAAA,aAAa,CAAC,SAAD,EAAY,IAAI,CAAC,SAAjB,EAA4B,OAA5B,EAAqC,UAArC,CAAb;AACD;AACF,CARL;;AAUA,MAAM,UAAU,GAAI,IAAD,IAAmB;AACpC,EAAA,WAAW,CACP,IAAI,CAAC,SAAL,CAAe,UADR,EACqB,IAAI,CAAC,SAD1B,EACqC,IAAI,CAAC,OAAL,CAAa,WADlD,CAAX;AAED,CAHD,C,CAKA;AACA;AACA;;;AACA,MAAM,WAAW,GAAG,CAAC,IAAD,EAAkB,KAAlB,EAAiC,GAAjC,KAAgD;AAClE,QAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;;AACA,OAAK,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,IAAI,GAAzB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,IAAA,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,CAAD,CAAZ,EAAiB,CAAjB;AACD;;AACD,SAAO,GAAP;AACD,CAND,C,CAQA;;;AACA,MAAM,aAAa,GAAG,IAAI,OAAJ,EAAtB;AACA,MAAM,YAAY,GAAG,IAAI,OAAJ,EAArB;AAEA;;;;;;;;;;;;;;;;;;;;AAmBA,OAAO,MAAM,MAAM,GACf,SAAS,CACL,CAAI,KAAJ,EACI,eADJ,EAEI,QAFJ,KAGkB;AACZ,MAAI,KAAJ;;AACA,MAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,IAAA,QAAQ,GAAG,eAAX;AACD,GAFD,MAEO,IAAI,eAAe,KAAK,SAAxB,EAAmC;AACxC,IAAA,KAAK,GAAG,eAAR;AACD;;AAED,SAAQ,aAAD,IAA8B;AACnC,QAAI,EAAE,aAAa,YAAY,QAA3B,CAAJ,EAA0C;AACxC,YAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD,KAHkC,CAInC;AACA;;;AACA,UAAM,QAAQ,GAAG,aAAa,CAAC,GAAd,CAAkB,aAAlB,KAAoC,EAArD;AACA,UAAM,OAAO,GAAG,YAAY,CAAC,GAAb,CAAiB,aAAjB,KAAmC,EAAnD,CAPmC,CASnC;AACA;AACA;;AACA,UAAM,QAAQ,GAAe,EAA7B,CAZmC,CAcnC;AACA;;AACA,UAAM,SAAS,GAAc,EAA7B;AACA,UAAM,OAAO,GAAc,EAA3B;AACA,QAAI,KAAK,GAAG,CAAZ;;AACA,SAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;AACxB,MAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,KAAK,GAAG,KAAK,CAAC,IAAD,EAAO,KAAP,CAAR,GAAwB,KAA9C;AACA,MAAA,SAAS,CAAC,KAAD,CAAT,GAAmB,QAAU,CAAC,IAAD,EAAO,KAAP,CAA7B;AACA,MAAA,KAAK;AACN,KAvBkC,CAyBnC;AACA;AACA;AACA;;;AACA,QAAI,gBAAJ;AACA,QAAI,gBAAJ,CA9BmC,CAgCnC;;AACA,QAAI,OAAO,GAAG,CAAd;AACA,QAAI,OAAO,GAAG,QAAQ,CAAC,MAAT,GAAkB,CAAhC;AACA,QAAI,OAAO,GAAG,CAAd;AACA,QAAI,OAAO,GAAG,SAAS,CAAC,MAAV,GAAmB,CAAjC,CApCmC,CAsCnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAO,OAAO,IAAI,OAA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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {DirectiveFn} from '../lib/directive.js';\nimport {createMarker, directive, NodePart, Part, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.options);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\n\nconst updatePart = (part: NodePart, value: unknown) => {\n  part.setValue(value);\n  part.commit();\n  return part;\n};\n\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\n\nconst removePart = (part: NodePart) => {\n  removeNodes(\n      part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n};\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\nconst keyListCache = new WeakMap<NodePart, unknown[]>();\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat =\n    directive(\n        <T>(items: Iterable<T>,\n            keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n            template?: ItemTemplate<T>):\n            DirectiveFn => {\n              let keyFn: KeyFn<T>;\n              if (template === undefined) {\n                template = keyFnOrTemplate;\n              } else if (keyFnOrTemplate !== undefined) {\n                keyFn = keyFnOrTemplate as KeyFn<T>;\n              }\n\n              return (containerPart: Part): void => {\n                if (!(containerPart instanceof NodePart)) {\n                  throw new Error('repeat can only be used in text bindings');\n                }\n                // Old part & key lists are retrieved from the last update\n                // (associated with the part for this instance of the directive)\n                const oldParts = partListCache.get(containerPart) || [];\n                const oldKeys = keyListCache.get(containerPart) || [];\n\n                // New part list will be built up as we go (either reused from\n                // old parts or created for new keys in this update). This is\n                // saved in the above cache at the end of the update.\n                const newParts: NodePart[] = [];\n\n                // New value list is eagerly generated from items along with a\n                // parallel array indicating its key.\n                const newValues: unknown[] = [];\n                const newKeys: unknown[] = [];\n                let index = 0;\n                for (const item of items) {\n                  newKeys[index] = keyFn ? keyFn(item, index) : index;\n                  newValues[index] = template !(item, index);\n                  index++;\n                }\n\n                // Maps from key to index for current and previous update; these\n                // are generated lazily only when needed as a performance\n                // optimization, since they are only required for multiple\n                // non-contiguous changes in the list, which are less common.\n                let newKeyToIndexMap!: Map<unknown, number>;\n                let oldKeyToIndexMap!: Map<unknown, number>;\n\n                // Head and tail pointers to old parts and new values\n                let oldHead = 0;\n                let oldTail = oldParts.length - 1;\n                let newHead = 0;\n                let newTail = newValues.length - 1;\n\n                // Overview of O(n) reconciliation algorithm (general approach\n                // based on ideas found in ivi, vue, snabbdom, etc.):\n                //\n                // * We start with the list of old parts and new values (and\n                //   arrays of their respective keys), head/tail pointers into\n                //   each, and we build up the new list of parts by updating\n                //   (and when needed, moving) old parts or creating new ones.\n                //   The initial scenario might look like this (for brevity of\n                //   the diagrams, the numbers in the array reflect keys\n                //   associated with the old parts or new values, although keys\n                //   and parts/values are actually stored in parallel arrays\n                //   indexed using the same head/tail pointers):\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n                //                                      item order\n                //      newHead ^                 ^ newTail\n                //\n                // * Iterate old & new lists from both sides, updating,\n                //   swapping, or removing parts at the head/tail locations\n                //   until neither head nor tail can move.\n                //\n                // * Example below: keys at head pointers match, so update old\n                //   part 0 in-place (no need to move it) and record part 0 in\n                //   the `newParts` list. The last thing we do is advance the\n                //   `oldHead` and `newHead` pointers (will be reflected in the\n                //   next diagram).\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n                //                                      & newHead\n                //      newHead ^                 ^ newTail\n                //\n                // * Example below: head pointers don't match, but tail\n                //   pointers do, so update part 6 in place (no need to move\n                //   it), and record part 6 in the `newParts` list. Last,\n                //   advance the `oldTail` and `oldHead` pointers.\n                //\n                //         oldHead v              v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n                //                                      & newTail\n                //         newHead ^              ^ newTail\n                //\n                // * If neither head nor tail match; next check if one of the\n                //   old head/tail items was removed. We first need to generate\n                //   the reverse map of new keys to index (`newKeyToIndexMap`),\n                //   which is done once lazily as a performance optimization,\n                //   since we only hit this case if multiple non-contiguous\n                //   changes were made. Note that for contiguous removal\n                //   anywhere in the list, the head and tails would advance\n                //   from either end and pass each other before we get to this\n                //   case and removals would be handled in the final while loop\n                //   without needing to generate the map.\n                //\n                // * Example below: The key at `oldTail` was removed (no longer\n                //   in the `newKeyToIndexMap`), so remove that part from the\n                //   DOM and advance just the `oldTail` pointer.\n                //\n                //         oldHead v           v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n                //         newHead ^           ^ newTail\n                //\n                // * Once head and tail cannot move, any mismatches are due to\n                //   either new or moved items; if a new key is in the previous\n                //   \"old key to old index\" map, move the old part to the new\n                //   location, otherwise create and insert a new part. Note\n                //   that when moving an old part we null its position in the\n                //   oldParts array if it lies between the head and tail so we\n                //   know to skip it when the pointers get there.\n                //\n                // * Example below: neither head nor tail match, and neither\n                //   were removed; so find the `newHead` key in the\n                //   `oldKeyToIndexMap`, and move that old part's DOM into the\n                //   next head position (before `oldParts[oldHead]`). Last,\n                //   null the part in the `oldPart` array since it was\n                //   somewhere in the remaining oldParts still to be scanned\n                //   (between the head and tail pointers) so that we know to\n                //   skip that old part on future iterations.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n                //                                      newHead\n                //         newHead ^           ^ newTail\n                //\n                // * Note that for moves/insertions like the one above, a part\n                //   inserted at the head pointer is inserted before the\n                //   current `oldParts[oldHead]`, and a part inserted at the\n                //   tail pointer is inserted before `newParts[newTail+1]`. The\n                //   seeming asymmetry lies in the fact that new parts are\n                //   moved into place outside in, so to the right of the head\n                //   pointer are old parts, and to the right of the tail\n                //   pointer are new parts.\n                //\n                // * We always restart back from the top of the algorithm,\n                //   allowing matching and simple updates in place to\n                //   continue...\n                //\n                // * Example below: the head pointers once again match, so\n                //   simply update part 1 and record it in the `newParts`\n                //   array.  Last, advance both head pointers.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n                //                                      & newHead\n                //            newHead ^        ^ newTail\n                //\n                // * As mentioned above, items that were moved as a result of\n                //   being stuck (the final else clause in the code below) are\n                //   marked with null, so we always advance old pointers over\n                //   these so we're comparing the next actual old value on\n                //   either end.\n                //\n                // * Example below: `oldHead` is null (already placed in\n                //   newParts), so advance `oldHead`.\n                //\n                //            oldHead v     v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n                //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n                //               newHead ^     ^ newTail\n                //\n                // * Note it's not critical to mark old parts as null when they\n                //   are moved from head to tail or tail to head, since they\n                //   will be outside the pointer range and never visited again.\n                //\n                // * Example below: Here the old tail key matches the new head\n                //   key, so the part at the `oldTail` position and move its\n                //   DOM to the new head position (before `oldParts[oldHead]`).\n                //   Last, advance `oldTail` and `newHead` pointers.\n                //\n                //               oldHead v  v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n                //                                     advance oldTail & newHead\n                //               newHead ^     ^ newTail\n                //\n                // * Example below: Old and new head keys match, so update the\n                //   old head part in place, and advance the `oldHead` and\n                //   `newHead` pointers.\n                //\n                //               oldHead v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n                //                                      newHead\n                //                  newHead ^  ^ newTail\n                //\n                // * Once the new or old pointers move past each other then all\n                //   we have left is additions (if old list exhausted) or\n                //   removals (if new list exhausted). Those are handled in the\n                //   final while loops at the end.\n                //\n                // * Example below: `oldHead` exceeded `oldTail`, so we're done\n                //   with the main loop.  Create the remaining part and insert\n                //   it at the new head position, and the update is complete.\n                //\n                //                   (oldHead > oldTail)\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n                //                     newHead ^ newTail\n                //\n                // * Note that the order of the if/else clauses is not\n                //   important to the algorithm, as long as the null checks\n                //   come first (to ensure we're always working on valid old\n                //   parts) and that the final else clause comes last (since\n                //   that's where the expensive moves occur). The order of\n                //   remaining clauses is is just a simple guess at which cases\n                //   will be most common.\n                //\n                // * TODO(kschaaf) Note, we could calculate the longest\n                //   increasing subsequence (LIS) of old items in new position,\n                //   and only move those not in the LIS set. However that costs\n                //   O(nlogn) time and adds a bit more code, and only helps\n                //   make rare types of mutations require fewer moves. The\n                //   above handles removes, adds, reversal, swaps, and single\n                //   moves of contiguous items in linear time, in the minimum\n                //   number of moves. As the number of multiple moves where LIS\n                //   might help approaches a random shuffle, the LIS\n                //   optimization becomes less helpful, so it seems not worth\n                //   the code at this point. Could reconsider if a compelling\n                //   case arises.\n\n                while (oldHead <= oldTail && newHead <= newTail) {\n                  if (oldParts[oldHead] === null) {\n                    // `null` means old part at head has already been used\n                    // below; skip\n                    oldHead++;\n                  } else if (oldParts[oldTail] === null) {\n                    // `null` means old part at tail has already been used\n                    // below; skip\n                    oldTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newHead]) {\n                    // Old head matches new head; update in place\n                    newParts[newHead] =\n                        updatePart(oldParts[oldHead]!, newValues[newHead]);\n                    oldHead++;\n                    newHead++;\n                  } else if (oldKeys[oldTail] === newKeys[newTail]) {\n                    // Old tail matches new tail; update in place\n                    newParts[newTail] =\n                        updatePart(oldParts[oldTail]!, newValues[newTail]);\n                    oldTail--;\n                    newTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newTail]) {\n                    // Old head matches new tail; update and move to new tail\n                    newParts[newTail] =\n                        updatePart(oldParts[oldHead]!, newValues[newTail]);\n                    insertPartBefore(\n                        containerPart,\n                        oldParts[oldHead]!,\n                        newParts[newTail + 1]);\n                    oldHead++;\n                    newTail--;\n                  } else if (oldKeys[oldTail] === newKeys[newHead]) {\n                    // Old tail matches new head; update and move to new head\n                    newParts[newHead] =\n                        updatePart(oldParts[oldTail]!, newValues[newHead]);\n                    insertPartBefore(\n                        containerPart, oldParts[oldTail]!, oldParts[oldHead]!);\n                    oldTail--;\n                    newHead++;\n                  } else {\n                    if (newKeyToIndexMap === undefined) {\n                      // Lazily generate key-to-index maps, used for removals &\n                      // moves below\n                      newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                      oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                    }\n                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                      // Old head is no longer in new list; remove\n                      removePart(oldParts[oldHead]!);\n                      oldHead++;\n                    } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                      // Old tail is no longer in new list; remove\n                      removePart(oldParts[oldTail]!);\n                      oldTail--;\n                    } else {\n                      // Any mismatches at this point are due to additions or\n                      // moves; see if we have an old part we can reuse and move\n                      // into place\n                      const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                      const oldPart =\n                          oldIndex !== undefined ? oldParts[oldIndex] : null;\n                      if (oldPart === null) {\n                        // No old part for this value; create a new one and\n                        // insert it\n                        const newPart = createAndInsertPart(\n                            containerPart, oldParts[oldHead]!);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                      } else {\n                        // Reuse old part\n                        newParts[newHead] =\n                            updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(\n                            containerPart, oldPart, oldParts[oldHead]!);\n                        // This marks the old part as having been used, so that\n                        // it will be skipped in the first two checks above\n                        oldParts[oldIndex as number] = null;\n                      }\n                      newHead++;\n                    }\n                  }\n                }\n                // Add parts for any remaining new values\n                while (newHead <= newTail) {\n                  // For all remaining additions, we insert before last new\n                  // tail, since old pointers are no longer valid\n                  const newPart =\n                      createAndInsertPart(containerPart, newParts[newTail + 1]);\n                  updatePart(newPart, newValues[newHead]);\n                  newParts[newHead++] = newPart;\n                }\n                // Remove any remaining unused old parts\n                while (oldHead <= oldTail) {\n                  const oldPart = oldParts[oldHead++];\n                  if (oldPart !== null) {\n                    removePart(oldPart);\n                  }\n                }\n                // Save order of new parts for next round\n                partListCache.set(containerPart, newParts);\n                keyListCache.set(containerPart, newKeys);\n              };\n            }) as\n    <T>(items: Iterable<T>,\n        keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n        template?: ItemTemplate<T>) => DirectiveFn;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}