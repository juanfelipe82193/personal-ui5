{"ast":null,"code":"// Shorthands\nconst w = window; // Map of observer objects per dom node\n\nconst observers = new WeakMap();\n/**\n * Implements universal DOM node observation methods.\n */\n\nclass DOMObserver {\n  constructor() {\n    throw new Error(\"Static class\");\n  }\n  /**\n   * This function abstracts out mutation observer usage inside shadow DOM.\n   * For native shadow DOM the native mutation observer is used.\n   * When the polyfill is used, the observeChildren ShadyDOM method is used instead.\n   *\n   * @throws Exception\n   * Note: does not allow several mutation observers per node. If there is a valid use-case, this behavior can be changed.\n   *\n   * @param node\n   * @param callback\n   * @param options - Only used for the native mutation observer\n   */\n\n\n  static observeDOMNode(node, callback, options) {\n    let observerObject = observers.get(node);\n\n    if (observerObject) {\n      throw new Error(\"A mutation/ShadyDOM observer is already assigned to this node.\");\n    }\n\n    if (w.ShadyDOM) {\n      observerObject = w.ShadyDOM.observeChildren(node, callback);\n    } else {\n      observerObject = new MutationObserver(callback);\n      observerObject.observe(node, options);\n    }\n\n    observers.set(node, observerObject);\n  }\n  /**\n   * De-registers the mutation observer, depending on its type\n   * @param node\n   */\n\n\n  static unobserveDOMNode(node) {\n    const observerObject = observers.get(node);\n\n    if (!observerObject) {\n      return;\n    }\n\n    if (observerObject instanceof MutationObserver) {\n      observerObject.disconnect();\n    } else {\n      w.ShadyDOM.unobserveChildren(observerObject);\n    }\n\n    observers.delete(node);\n  }\n\n}\n\nexport default DOMObserver;","map":{"version":3,"sources":["/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/@ui5/webcomponents-base/dist/compatibility/DOMObserver.js"],"names":["w","window","observers","WeakMap","DOMObserver","constructor","Error","observeDOMNode","node","callback","options","observerObject","get","ShadyDOM","observeChildren","MutationObserver","observe","set","unobserveDOMNode","disconnect","unobserveChildren","delete"],"mappings":"AAAA;AACA,MAAMA,CAAC,GAAGC,MAAV,C,CAEA;;AACA,MAAMC,SAAS,GAAG,IAAIC,OAAJ,EAAlB;AAEA;;;;AAGA,MAAMC,WAAN,CAAkB;AACjBC,EAAAA,WAAW,GAAG;AACb,UAAM,IAAIC,KAAJ,CAAU,cAAV,CAAN;AACA;AAED;;;;;;;;;;;;;;AAYA,SAAOC,cAAP,CAAsBC,IAAtB,EAA4BC,QAA5B,EAAsCC,OAAtC,EAA+C;AAC9C,QAAIC,cAAc,GAAGT,SAAS,CAACU,GAAV,CAAcJ,IAAd,CAArB;;AACA,QAAIG,cAAJ,EAAoB;AACnB,YAAM,IAAIL,KAAJ,CAAU,gEAAV,CAAN;AACA;;AAED,QAAIN,CAAC,CAACa,QAAN,EAAgB;AACfF,MAAAA,cAAc,GAAGX,CAAC,CAACa,QAAF,CAAWC,eAAX,CAA2BN,IAA3B,EAAiCC,QAAjC,CAAjB;AACA,KAFD,MAEO;AACNE,MAAAA,cAAc,GAAG,IAAII,gBAAJ,CAAqBN,QAArB,CAAjB;AACAE,MAAAA,cAAc,CAACK,OAAf,CAAuBR,IAAvB,EAA6BE,OAA7B;AACA;;AAEDR,IAAAA,SAAS,CAACe,GAAV,CAAcT,IAAd,EAAoBG,cAApB;AACA;AAED;;;;;;AAIA,SAAOO,gBAAP,CAAwBV,IAAxB,EAA8B;AAC7B,UAAMG,cAAc,GAAGT,SAAS,CAACU,GAAV,CAAcJ,IAAd,CAAvB;;AACA,QAAI,CAACG,cAAL,EAAqB;AACpB;AACA;;AAED,QAAIA,cAAc,YAAYI,gBAA9B,EAAgD;AAC/CJ,MAAAA,cAAc,CAACQ,UAAf;AACA,KAFD,MAEO;AACNnB,MAAAA,CAAC,CAACa,QAAF,CAAWO,iBAAX,CAA6BT,cAA7B;AACA;;AACDT,IAAAA,SAAS,CAACmB,MAAV,CAAiBb,IAAjB;AACA;;AAjDgB;;AAoDlB,eAAeJ,WAAf","sourcesContent":["// Shorthands\nconst w = window;\n\n// Map of observer objects per dom node\nconst observers = new WeakMap();\n\n/**\n * Implements universal DOM node observation methods.\n */\nclass DOMObserver {\n\tconstructor() {\n\t\tthrow new Error(\"Static class\");\n\t}\n\n\t/**\n\t * This function abstracts out mutation observer usage inside shadow DOM.\n\t * For native shadow DOM the native mutation observer is used.\n\t * When the polyfill is used, the observeChildren ShadyDOM method is used instead.\n\t *\n\t * @throws Exception\n\t * Note: does not allow several mutation observers per node. If there is a valid use-case, this behavior can be changed.\n\t *\n\t * @param node\n\t * @param callback\n\t * @param options - Only used for the native mutation observer\n\t */\n\tstatic observeDOMNode(node, callback, options) {\n\t\tlet observerObject = observers.get(node);\n\t\tif (observerObject) {\n\t\t\tthrow new Error(\"A mutation/ShadyDOM observer is already assigned to this node.\");\n\t\t}\n\n\t\tif (w.ShadyDOM) {\n\t\t\tobserverObject = w.ShadyDOM.observeChildren(node, callback);\n\t\t} else {\n\t\t\tobserverObject = new MutationObserver(callback);\n\t\t\tobserverObject.observe(node, options);\n\t\t}\n\n\t\tobservers.set(node, observerObject);\n\t}\n\n\t/**\n\t * De-registers the mutation observer, depending on its type\n\t * @param node\n\t */\n\tstatic unobserveDOMNode(node) {\n\t\tconst observerObject = observers.get(node);\n\t\tif (!observerObject) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (observerObject instanceof MutationObserver) {\n\t\t\tobserverObject.disconnect();\n\t\t} else {\n\t\t\tw.ShadyDOM.unobserveChildren(observerObject);\n\t\t}\n\t\tobservers.delete(node);\n\t}\n}\n\nexport default DOMObserver;\n"]},"metadata":{},"sourceType":"module"}