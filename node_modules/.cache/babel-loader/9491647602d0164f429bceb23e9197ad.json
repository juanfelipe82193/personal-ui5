{"ast":null,"code":"import RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\nconst MAX_RERENDER_COUNT = 10; // Tells whether a render task is currently scheduled\n\nlet renderTaskId; // Queue for invalidated web components\n\nconst invalidatedWebComponents = new RenderQueue();\nlet renderTaskPromise, renderTaskPromiseResolve, taskResult;\nlet mutationObserverTimer;\n/**\n * Class that manages the rendering/re-rendering of web components\n * This is always asynchronous\n */\n\nclass RenderScheduler {\n  constructor() {\n    throw new Error(\"Static class\");\n  }\n  /**\n   * Queues a web component for re-rendering\n   * @param webComponent\n   */\n\n\n  static renderDeferred(webComponent) {\n    // Enqueue the web component\n    const res = invalidatedWebComponents.add(webComponent); // Schedule a rendering task\n\n    RenderScheduler.scheduleRenderTask();\n    return res;\n  }\n\n  static renderImmediately(webComponent) {\n    // Enqueue the web component\n    const res = invalidatedWebComponents.add(webComponent); // Immediately start a render task\n\n    RenderScheduler.runRenderTask();\n    return res;\n  }\n  /**\n   * Schedules a rendering task, if not scheduled already\n   */\n\n\n  static scheduleRenderTask() {\n    if (!renderTaskId) {\n      // renderTaskId = window.setTimeout(RenderScheduler.renderWebComponents, 3000); // Task\n      // renderTaskId = Promise.resolve().then(RenderScheduler.renderWebComponents); // Micro task\n      renderTaskId = window.requestAnimationFrame(RenderScheduler.renderWebComponents); // AF\n    }\n  }\n\n  static runRenderTask() {\n    if (!renderTaskId) {\n      renderTaskId = 1; // prevent another rendering task from being scheduled, all web components should use this task\n\n      RenderScheduler.renderWebComponents();\n    }\n  }\n\n  static renderWebComponents() {\n    // console.log(\"------------- NEW RENDER TASK ---------------\");\n    let webComponentInfo, webComponent, promise;\n    const renderStats = new Map();\n\n    while (webComponentInfo = invalidatedWebComponents.shift()) {\n      // eslint-disable-line\n      webComponent = webComponentInfo.webComponent;\n      promise = webComponentInfo.promise;\n      const timesRerendered = renderStats.get(webComponent) || 0;\n\n      if (timesRerendered > MAX_RERENDER_COUNT) {\n        // console.warn(\"WARNING RERENDER\", webComponent);\n        throw new Error(`Web component re-rendered too many times this task, max allowed is: ${MAX_RERENDER_COUNT}`);\n      }\n\n      webComponent._render();\n\n      promise._deferredResolve();\n\n      renderStats.set(webComponent, timesRerendered + 1);\n    } // wait for Mutation observer just in case\n\n\n    if (!mutationObserverTimer) {\n      mutationObserverTimer = setTimeout(() => {\n        mutationObserverTimer = undefined;\n\n        if (invalidatedWebComponents.getList().length === 0) {\n          RenderScheduler._resolveTaskPromise();\n        }\n      }, 200);\n    }\n\n    renderTaskId = undefined;\n  }\n  /**\n   * return a promise that will be resolved once all invalidated web components are rendered\n   */\n\n\n  static whenDOMUpdated() {\n    if (renderTaskPromise) {\n      return renderTaskPromise;\n    }\n\n    renderTaskPromise = new Promise(resolve => {\n      renderTaskPromiseResolve = resolve;\n      window.requestAnimationFrame(() => {\n        if (invalidatedWebComponents.getList().length === 0) {\n          renderTaskPromise = undefined;\n          resolve();\n        }\n      });\n    });\n    return renderTaskPromise;\n  }\n\n  static whenAllCustomElementsAreDefined() {\n    const definedPromises = getAllRegisteredTags().map(tag => customElements.whenDefined(tag));\n    return Promise.all(definedPromises);\n  }\n\n  static async whenFinished() {\n    await RenderScheduler.whenAllCustomElementsAreDefined();\n    await RenderScheduler.whenDOMUpdated();\n  }\n\n  static _resolveTaskPromise() {\n    if (invalidatedWebComponents.getList().length > 0) {\n      // More updates are pending. Resolve will be called again\n      return;\n    }\n\n    if (renderTaskPromiseResolve) {\n      renderTaskPromiseResolve.call(this, taskResult);\n      renderTaskPromiseResolve = undefined;\n      renderTaskPromise = undefined;\n    }\n  }\n\n}\n\nexport default RenderScheduler;","map":{"version":3,"sources":["/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/@ui5/webcomponents-base/dist/RenderScheduler.js"],"names":["RenderQueue","getAllRegisteredTags","MAX_RERENDER_COUNT","renderTaskId","invalidatedWebComponents","renderTaskPromise","renderTaskPromiseResolve","taskResult","mutationObserverTimer","RenderScheduler","constructor","Error","renderDeferred","webComponent","res","add","scheduleRenderTask","renderImmediately","runRenderTask","window","requestAnimationFrame","renderWebComponents","webComponentInfo","promise","renderStats","Map","shift","timesRerendered","get","_render","_deferredResolve","set","setTimeout","undefined","getList","length","_resolveTaskPromise","whenDOMUpdated","Promise","resolve","whenAllCustomElementsAreDefined","definedPromises","map","tag","customElements","whenDefined","all","whenFinished","call"],"mappings":"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","sourcesContent":["import RenderQueue from \"./RenderQueue.js\";\nimport { getAllRegisteredTags } from \"./CustomElementsRegistry.js\";\n\nconst MAX_RERENDER_COUNT = 10;\n\n// Tells whether a render task is currently scheduled\nlet renderTaskId;\n\n// Queue for invalidated web components\nconst invalidatedWebComponents = new RenderQueue();\n\nlet renderTaskPromise,\n\trenderTaskPromiseResolve,\n\ttaskResult;\n\nlet mutationObserverTimer;\n\n/**\n * Class that manages the rendering/re-rendering of web components\n * This is always asynchronous\n */\nclass RenderScheduler {\n\tconstructor() {\n\t\tthrow new Error(\"Static class\");\n\t}\n\n\t/**\n\t * Queues a web component for re-rendering\n\t * @param webComponent\n\t */\n\tstatic renderDeferred(webComponent) {\n\t\t// Enqueue the web component\n\t\tconst res = invalidatedWebComponents.add(webComponent);\n\n\t\t// Schedule a rendering task\n\t\tRenderScheduler.scheduleRenderTask();\n\t\treturn res;\n\t}\n\n\tstatic renderImmediately(webComponent) {\n\t\t// Enqueue the web component\n\t\tconst res = invalidatedWebComponents.add(webComponent);\n\n\t\t// Immediately start a render task\n\t\tRenderScheduler.runRenderTask();\n\t\treturn res;\n\t}\n\n\t/**\n\t * Schedules a rendering task, if not scheduled already\n\t */\n\tstatic scheduleRenderTask() {\n\t\tif (!renderTaskId) {\n\t\t\t// renderTaskId = window.setTimeout(RenderScheduler.renderWebComponents, 3000); // Task\n\t\t\t// renderTaskId = Promise.resolve().then(RenderScheduler.renderWebComponents); // Micro task\n\t\t\trenderTaskId = window.requestAnimationFrame(RenderScheduler.renderWebComponents); // AF\n\t\t}\n\t}\n\n\tstatic runRenderTask() {\n\t\tif (!renderTaskId) {\n\t\t\trenderTaskId = 1; // prevent another rendering task from being scheduled, all web components should use this task\n\t\t\tRenderScheduler.renderWebComponents();\n\t\t}\n\t}\n\n\tstatic renderWebComponents() {\n\t\t// console.log(\"------------- NEW RENDER TASK ---------------\");\n\n\t\tlet webComponentInfo,\n\t\t\twebComponent,\n\t\t\tpromise;\n\t\tconst renderStats = new Map();\n\t\twhile (webComponentInfo = invalidatedWebComponents.shift()) { // eslint-disable-line\n\t\t\twebComponent = webComponentInfo.webComponent;\n\t\t\tpromise = webComponentInfo.promise;\n\n\t\t\tconst timesRerendered = renderStats.get(webComponent) || 0;\n\t\t\tif (timesRerendered > MAX_RERENDER_COUNT) {\n\t\t\t\t// console.warn(\"WARNING RERENDER\", webComponent);\n\t\t\t\tthrow new Error(`Web component re-rendered too many times this task, max allowed is: ${MAX_RERENDER_COUNT}`);\n\t\t\t}\n\t\t\twebComponent._render();\n\t\t\tpromise._deferredResolve();\n\t\t\trenderStats.set(webComponent, timesRerendered + 1);\n\t\t}\n\n\t\t// wait for Mutation observer just in case\n\t\tif (!mutationObserverTimer) {\n\t\t\tmutationObserverTimer = setTimeout(() => {\n\t\t\t\tmutationObserverTimer = undefined;\n\t\t\t\tif (invalidatedWebComponents.getList().length === 0) {\n\t\t\t\t\tRenderScheduler._resolveTaskPromise();\n\t\t\t\t}\n\t\t\t}, 200);\n\t\t}\n\n\t\trenderTaskId = undefined;\n\t}\n\n\t/**\n\t * return a promise that will be resolved once all invalidated web components are rendered\n\t */\n\tstatic whenDOMUpdated() {\n\t\tif (renderTaskPromise) {\n\t\t\treturn renderTaskPromise;\n\t\t}\n\n\t\trenderTaskPromise = new Promise(resolve => {\n\t\t\trenderTaskPromiseResolve = resolve;\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\tif (invalidatedWebComponents.getList().length === 0) {\n\t\t\t\t\trenderTaskPromise = undefined;\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn renderTaskPromise;\n\t}\n\n\tstatic whenAllCustomElementsAreDefined() {\n\t\tconst definedPromises = getAllRegisteredTags().map(tag => customElements.whenDefined(tag));\n\t\treturn Promise.all(definedPromises);\n\t}\n\n\tstatic async whenFinished() {\n\t\tawait RenderScheduler.whenAllCustomElementsAreDefined();\n\t\tawait RenderScheduler.whenDOMUpdated();\n\t}\n\n\tstatic _resolveTaskPromise() {\n\t\tif (invalidatedWebComponents.getList().length > 0) {\n\t\t\t// More updates are pending. Resolve will be called again\n\t\t\treturn;\n\t\t}\n\n\t\tif (renderTaskPromiseResolve) {\n\t\t\trenderTaskPromiseResolve.call(this, taskResult);\n\t\t\trenderTaskPromiseResolve = undefined;\n\t\t\trenderTaskPromise = undefined;\n\t\t}\n\t}\n}\n\nexport default RenderScheduler;\n"]},"metadata":{},"sourceType":"module"}