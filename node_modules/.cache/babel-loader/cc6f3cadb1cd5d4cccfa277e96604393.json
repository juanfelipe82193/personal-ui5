{"ast":null,"code":"import _classCallCheck from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Shorthands\nvar w = window; // Map of observer objects per dom node\n\nvar observers = new WeakMap();\n/**\n * Implements universal DOM node observation methods.\n */\n\nvar DOMObserver = /*#__PURE__*/function () {\n  function DOMObserver() {\n    _classCallCheck(this, DOMObserver);\n\n    throw new Error(\"Static class\");\n  }\n  /**\n   * This function abstracts out mutation observer usage inside shadow DOM.\n   * For native shadow DOM the native mutation observer is used.\n   * When the polyfill is used, the observeChildren ShadyDOM method is used instead.\n   *\n   * @throws Exception\n   * Note: does not allow several mutation observers per node. If there is a valid use-case, this behavior can be changed.\n   *\n   * @param node\n   * @param callback\n   * @param options - Only used for the native mutation observer\n   */\n\n\n  _createClass(DOMObserver, null, [{\n    key: \"observeDOMNode\",\n    value: function observeDOMNode(node, callback, options) {\n      var observerObject = observers.get(node);\n\n      if (observerObject) {\n        throw new Error(\"A mutation/ShadyDOM observer is already assigned to this node.\");\n      }\n\n      if (w.ShadyDOM) {\n        observerObject = w.ShadyDOM.observeChildren(node, callback);\n      } else {\n        observerObject = new MutationObserver(callback);\n        observerObject.observe(node, options);\n      }\n\n      observers.set(node, observerObject);\n    }\n    /**\n     * De-registers the mutation observer, depending on its type\n     * @param node\n     */\n\n  }, {\n    key: \"unobserveDOMNode\",\n    value: function unobserveDOMNode(node) {\n      var observerObject = observers.get(node);\n\n      if (!observerObject) {\n        return;\n      }\n\n      if (observerObject instanceof MutationObserver) {\n        observerObject.disconnect();\n      } else {\n        w.ShadyDOM.unobserveChildren(observerObject);\n      }\n\n      observers.delete(node);\n    }\n  }]);\n\n  return DOMObserver;\n}();\n\nexport default DOMObserver;","map":{"version":3,"sources":["/Users/juanzorrilla/Documents/SAPUI5/personal-ui5/node_modules/@ui5/webcomponents-base/dist/compatibility/DOMObserver.js"],"names":["w","window","observers","WeakMap","DOMObserver","Error","node","callback","options","observerObject","get","ShadyDOM","observeChildren","MutationObserver","observe","set","disconnect","unobserveChildren","delete"],"mappings":";;AAAA;AACA,IAAMA,CAAC,GAAGC,MAAV,C,CAEA;;AACA,IAAMC,SAAS,GAAG,IAAIC,OAAJ,EAAlB;AAEA;;;;IAGMC,W;AACL,yBAAc;AAAA;;AACb,UAAM,IAAIC,KAAJ,CAAU,cAAV,CAAN;AACA;AAED;;;;;;;;;;;;;;;;mCAYsBC,I,EAAMC,Q,EAAUC,O,EAAS;AAC9C,UAAIC,cAAc,GAAGP,SAAS,CAACQ,GAAV,CAAcJ,IAAd,CAArB;;AACA,UAAIG,cAAJ,EAAoB;AACnB,cAAM,IAAIJ,KAAJ,CAAU,gEAAV,CAAN;AACA;;AAED,UAAIL,CAAC,CAACW,QAAN,EAAgB;AACfF,QAAAA,cAAc,GAAGT,CAAC,CAACW,QAAF,CAAWC,eAAX,CAA2BN,IAA3B,EAAiCC,QAAjC,CAAjB;AACA,OAFD,MAEO;AACNE,QAAAA,cAAc,GAAG,IAAII,gBAAJ,CAAqBN,QAArB,CAAjB;AACAE,QAAAA,cAAc,CAACK,OAAf,CAAuBR,IAAvB,EAA6BE,OAA7B;AACA;;AAEDN,MAAAA,SAAS,CAACa,GAAV,CAAcT,IAAd,EAAoBG,cAApB;AACA;AAED;;;;;;;qCAIwBH,I,EAAM;AAC7B,UAAMG,cAAc,GAAGP,SAAS,CAACQ,GAAV,CAAcJ,IAAd,CAAvB;;AACA,UAAI,CAACG,cAAL,EAAqB;AACpB;AACA;;AAED,UAAIA,cAAc,YAAYI,gBAA9B,EAAgD;AAC/CJ,QAAAA,cAAc,CAACO,UAAf;AACA,OAFD,MAEO;AACNhB,QAAAA,CAAC,CAACW,QAAF,CAAWM,iBAAX,CAA6BR,cAA7B;AACA;;AACDP,MAAAA,SAAS,CAACgB,MAAV,CAAiBZ,IAAjB;AACA;;;;;;AAGF,eAAeF,WAAf","sourcesContent":["// Shorthands\nconst w = window;\n\n// Map of observer objects per dom node\nconst observers = new WeakMap();\n\n/**\n * Implements universal DOM node observation methods.\n */\nclass DOMObserver {\n\tconstructor() {\n\t\tthrow new Error(\"Static class\");\n\t}\n\n\t/**\n\t * This function abstracts out mutation observer usage inside shadow DOM.\n\t * For native shadow DOM the native mutation observer is used.\n\t * When the polyfill is used, the observeChildren ShadyDOM method is used instead.\n\t *\n\t * @throws Exception\n\t * Note: does not allow several mutation observers per node. If there is a valid use-case, this behavior can be changed.\n\t *\n\t * @param node\n\t * @param callback\n\t * @param options - Only used for the native mutation observer\n\t */\n\tstatic observeDOMNode(node, callback, options) {\n\t\tlet observerObject = observers.get(node);\n\t\tif (observerObject) {\n\t\t\tthrow new Error(\"A mutation/ShadyDOM observer is already assigned to this node.\");\n\t\t}\n\n\t\tif (w.ShadyDOM) {\n\t\t\tobserverObject = w.ShadyDOM.observeChildren(node, callback);\n\t\t} else {\n\t\t\tobserverObject = new MutationObserver(callback);\n\t\t\tobserverObject.observe(node, options);\n\t\t}\n\n\t\tobservers.set(node, observerObject);\n\t}\n\n\t/**\n\t * De-registers the mutation observer, depending on its type\n\t * @param node\n\t */\n\tstatic unobserveDOMNode(node) {\n\t\tconst observerObject = observers.get(node);\n\t\tif (!observerObject) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (observerObject instanceof MutationObserver) {\n\t\t\tobserverObject.disconnect();\n\t\t} else {\n\t\t\tw.ShadyDOM.unobserveChildren(observerObject);\n\t\t}\n\t\tobservers.delete(node);\n\t}\n}\n\nexport default DOMObserver;\n"]},"metadata":{},"sourceType":"module"}