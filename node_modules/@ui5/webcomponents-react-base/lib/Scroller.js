import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import React, { useMemo, forwardRef, useState, useRef, useCallback, useImperativeHandle, useEffect } from 'react';
import { deprecationNotice } from '@ui5/webcomponents-react-base/lib/Utils';
import { ScrollContext } from '@ui5/webcomponents-react-base/lib/ScrollContext';

var ScrollContentProvider = function ScrollContentProvider(props) {
  var children = props.children,
      scrollContainer = props.scrollContainer,
      registerElement = props.registerElement,
      unregisterElement = props.unregisterElement,
      scrollToElementById = props.scrollToElementById,
      selectedElementId = props.selectedElementId,
      scrollToTop = props.scrollToTop;
  var context = useMemo(function () {
    return {
      scrollContainer: scrollContainer,
      registerElement: registerElement,
      unregisterElement: unregisterElement,
      scrollToElementById: scrollToElementById,
      selectedElementId: selectedElementId,
      scrollToTop: scrollToTop
    };
  }, [scrollContainer, registerElement, unregisterElement, scrollToElementById, selectedElementId, scrollToTop]);
  return /*#__PURE__*/React.createElement(ScrollContext.Provider, {
    value: context
  }, children);
};

var defaultEasing = function defaultEasing(x) {
  if (x < 0.5) {
    return Math.pow(x * 2, 2) / 2;
  }

  return 1 - Math.pow((1 - x) * 2, 2) / 2;
};

var cancelEvents = ['mousedown', 'mousewheel', 'touchmove', 'keydown'];

var subscribeCancelEvent = function subscribeCancelEvent(cancelEvent) {
  return typeof document !== 'undefined' && cancelEvents.forEach(function (event) {
    return document.addEventListener(event, cancelEvent);
  });
};

var events = {
  registered: {},
  scrollEvent: {
    register: function register(evtName, callback) {
      events.registered[evtName] = callback;
    },
    remove: function remove(evtName) {
      events.registered[evtName] = null;
    }
  }
};

var functionWrapper = function functionWrapper(value) {
  return typeof value === 'function' ? value : function () {
    return value;
  };
};

var makeData = function makeData() {
  return {
    currentPositionY: 0,
    startPositionY: 0,
    targetPositionY: 0,
    progress: 0,
    duration: 400,
    cancel: false,
    target: null,
    scrollContainer: null,
    to: null,
    start: null,
    deltaTop: null,
    percent: null,
    delayTimeout: null
  };
};

var animateScroll = function animateScroll(easing, options, timestamp) {
  var data = options.data; // Cancel on specific events

  if (!options.ignoreCancelEvents && data.cancel) {
    // @ts-ignore
    if (events.registered.end) {
      // @ts-ignore
      events.registered.end(data.to, data.target, data.currentPositionY);
    }

    return;
  }

  data.deltaTop = Math.round(data.targetPositionY - data.startPositionY);

  if (data.start === null) {
    data.start = timestamp;
  }

  data.progress = timestamp - data.start;
  data.percent = data.progress >= data.duration ? 1 : easing(data.progress / data.duration);
  data.currentPositionY = data.startPositionY + Math.ceil(data.deltaTop * data.percent);
  var scrollContainer = options.scrollContainer; // @ts-ignore

  if (scrollContainer && scrollContainer.current && scrollContainer.current !== document && scrollContainer.current !== document.body) {
    // @ts-ignore
    scrollContainer.current.scrollTop = data.currentPositionY;
  } else {
    window.scrollTo(0, data.currentPositionY);
  }

  if (data.percent < 1) {
    var easedAnimate = animateScroll.bind(null, easing, options);
    requestAnimationFrame(easedAnimate);
    return;
  } // @ts-ignore


  if (events.registered.end) {
    // @ts-ignore
    events.registered.end(data.to, data.target, data.currentPositionY);
  }
};

var animateTopScroll = function animateTopScroll(y, options, to, target) {
  options.data = options.data || makeData();
  var scrollContainer = options.scrollContainer;
  subscribeCancelEvent(function () {
    options.data.cancel = true;
  });
  options.data.start = null;
  options.data.cancel = false;
  options.data.startPositionY = scrollContainer.current.scrollTop;
  options.data.targetPositionY = options.absolute ? y : y + options.data.startPositionY;

  if (options.data.startPositionY === options.data.targetPositionY) {
    // @ts-ignore
    if (events.registered.end) {
      // @ts-ignore
      events.registered.end(options.data.to, options.data.target, options.data.currentPositionY);
    }

    return;
  }

  options.data.deltaTop = Math.round(options.data.targetPositionY - options.data.startPositionY);
  options.data.duration = functionWrapper(options.duration)(options.data.deltaTop);
  options.data.duration = isNaN(parseFloat(options.data.duration)) ? 400 : parseFloat(options.data.duration);
  options.data.to = to;
  options.data.target = target;
  var easedAnimate = animateScroll.bind(null, defaultEasing, options); // @ts-ignore

  if (events.registered.begin) {
    // @ts-ignore
    events.registered.begin(options.data.to, options.data.target);
  }

  requestAnimationFrame(easedAnimate);
};

var scrollTo = function scrollTo(toY, options, to, target) {
  animateTopScroll(toY, options, to, target);
};

deprecationNotice('Scroller', "'@ui5/webcomponents-react-base/lib/Scroller' is deprecated and will be removed in the next major release.");
var Scroller = forwardRef(function (props, ref) {
  var children = props.children,
      scrollContainer = props.scrollContainer,
      _props$forceSelection = props.forceSelection,
      forceSelection = _props$forceSelection === void 0 ? true : _props$forceSelection;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      selectedElementId = _useState2[0],
      setSelectedElementId = _useState2[1];

  var elements = useRef([]);
  var unregisterElement = useCallback(function (id) {
    elements.current = elements.current.filter(function (item) {
      return item.id !== id;
    });
  }, [elements.current]);
  var onScrollContainerChanged = useCallback(function () {
    if (!scrollContainer.current) return;
    elements.current = elements.current.map(function (element) {
      return _objectSpread(_objectSpread({}, element), {}, {
        offsetTop: getOffset(element.htmlRef.current),
        elementHeight: element.htmlRef.current.getBoundingClientRect().height
      });
    }).sort(function (a, b) {
      return a.offsetTop - b.offsetTop;
    });

    if (scrollContainer.current) {
      scroll({
        target: scrollContainer.current
      });
    }
  }, [scrollContainer]);
  var registerElement = useCallback(function (element) {
    unregisterElement(element.id);
    elements.current.push(element);
    onScrollContainerChanged();
  }, [elements.current]);
  var scrollToElementById = useCallback(function (id) {
    var scrollOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var element = elements.current.find(function (item) {
      return item.id === id;
    });

    if (element) {
      var htmlRef = element.htmlRef;
      scrollTo(element.offsetTop + scrollOffset, {
        scrollContainer: scrollContainer,
        absolute: true
      }, id, htmlRef.current);
    }
  }, [elements.current]);
  var scrollToTop = useCallback(function () {
    scrollTo(0, {
      scrollContainer: scrollContainer,
      absolute: true
    }, null, null);
  }, [scrollContainer.current]);
  var getOffset = useCallback(function (el) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!el) return 0;
    var nextOffset = el.offsetTop + offset;

    if (el.parentElement === scrollContainer.current) {
      return nextOffset;
    }

    return getOffset(el.offsetParent, nextOffset);
  }, [scrollContainer]);
  var observer = useRef(new MutationObserver(onScrollContainerChanged));
  var scroll = useCallback(function (e) {
    var selectedElement = elements.current.find(function (item) {
      return item.spy && e.target.scrollTop >= item.offsetTop && e.target.scrollTop < item.offsetTop + item.elementHeight;
    });

    if (forceSelection) {
      if (elements.current[0] && e.target.scrollTop < elements.current[0].offsetTop) {
        selectedElement = elements.current[0];
      } else {
        var lastElement = elements.current[elements.current.length - 1];

        if (lastElement && e.target.scrollTop >= lastElement.offsetTop + lastElement.elementHeight) {
          selectedElement = lastElement;
        }
      }
    }

    if (selectedElement && selectedElement.id !== selectedElementId) {
      setSelectedElementId(selectedElement.id);
    } else if (!selectedElement && selectedElementId !== null) {
      setSelectedElementId(null);
    }
  }, [elements.current, selectedElementId, setSelectedElementId]);
  useImperativeHandle(ref, function () {
    return {
      scroll: scroll,
      scrollToElementById: scrollToElementById,
      scrollToTop: scrollToTop
    };
  }, [elements.current, scrollContainer, selectedElementId, setSelectedElementId]);
  useEffect(function () {
    if (scrollContainer.current) {
      observer.current.observe(scrollContainer.current, {
        attributes: true,
        subtree: true,
        childList: true
      });
    }

    return function () {
      observer.current.disconnect();
    };
  }, [scrollContainer]);
  return /*#__PURE__*/React.createElement(ScrollContentProvider, {
    scrollContainer: scrollContainer,
    registerElement: registerElement,
    unregisterElement: unregisterElement,
    scrollToElementById: scrollToElementById,
    selectedElementId: selectedElementId,
    scrollToTop: scrollToTop
  }, children);
});
Scroller.displayName = 'Scroller';

export { Scroller };
//# sourceMappingURL=Scroller.js.map
