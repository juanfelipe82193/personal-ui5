import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import { deprecationNotice } from '@ui5/webcomponents-react-base/lib/Utils';

var HSLColor = /*#__PURE__*/function () {
  function HSLColor(hue, saturation, lightness) {
    var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, HSLColor);

    this.hue = void 0;
    this.saturation = void 0;
    this.lightness = void 0;
    this.alpha = 1;
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
    deprecationNotice('HSLColor', "'@ui5/webcomponents-react-base/lib/HSLColor' is deprecated and will be removed in the next major release.");
  }

  _createClass(HSLColor, [{
    key: "getHue",
    value: function getHue() {
      return this.hue;
    }
  }, {
    key: "getSaturation",
    value: function getSaturation() {
      return this.saturation;
    }
  }, {
    key: "getLightness",
    value: function getLightness() {
      return this.lightness;
    }
  }, {
    key: "lighten",
    value: function lighten(amount) {
      this.lightness += amount;
      return this;
    }
  }, {
    key: "darken",
    value: function darken(amount) {
      this.lightness -= amount;
      return this;
    }
  }, {
    key: "saturate",
    value: function saturate(amount) {
      this.saturation += amount;
      return this;
    }
  }, {
    key: "desaturate",
    value: function desaturate(amount) {
      this.saturation -= amount;
      return this;
    }
  }, {
    key: "setAlpha",
    value: function setAlpha(amount) {
      this.alpha = amount;
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.alpha !== 1) {
        return "hsla(".concat(this.hue, ", ").concat(this.saturation, "%, ").concat(this.lightness, "%, ").concat(this.alpha, ")");
      }

      return "hsl(".concat(this.hue, ", ").concat(this.saturation, "%, ").concat(this.lightness, "%)");
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.toString();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new HSLColor(this.hue, this.saturation, this.lightness);
    }
    /**
     * Copied from https://github.com/Qix-/color-convert/blob/master/conversions.js
     */

  }, {
    key: "toRGB",
    value: function toRGB() {
      var h = this.hue / 360;
      var s = this.saturation / 100;
      var l = this.lightness / 100;
      var t2;
      var t3;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      var t1 = 2 * l - t2;
      var rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }
    /**
     * Copied from https://github.com/styled-components/polished/blob/master/src/color/getLuminance.js
     */

  }, {
    key: "getLuminance",
    value: function getLuminance(hsl) {
      var color = hsl ? HSLColor.of(hsl) : this;

      var _color$toRGB$map = color.toRGB().map(function (value) {
        var channel = value / 255;
        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
      }),
          _color$toRGB$map2 = _slicedToArray(_color$toRGB$map, 3),
          r = _color$toRGB$map2[0],
          g = _color$toRGB$map2[1],
          b = _color$toRGB$map2[2];

      return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));
    }
  }, {
    key: "contrast",
    value: function contrast() {
      var dark = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hsl(0, 0%, 0%)';
      var light = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hsl(0, 0%, 100%)';
      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.43;

      // Figure out which is actually light and dark:
      if (this.getLuminance(dark) > this.getLuminance(light)) {
        var t = light;
        light = dark;
        dark = t;
      }

      if (this.getLuminance() < threshold) {
        return light;
      } else {
        return dark;
      }
    }
  }, {
    key: "hsl",
    get: function get() {
      return this.toString();
    }
  }], [{
    key: "of",
    value: function of(hue, saturation, lightness, alpha) {
      if (typeof hue === 'string' && HSLColor.HSL_REGEX.test(hue)) {
        return HSLColor.fromHsl(hue);
      }

      if (typeof hue === 'string' && HSLColor.HEX_REGEX.test(hue)) {
        return HSLColor.fromHex(hue);
      }

      if (hue instanceof HSLColor) {
        return hue;
      }

      return new HSLColor(hue, saturation, lightness, alpha);
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var result = HSLColor.HEX_REGEX.exec(hex);
      var r = parseInt(''.padEnd(2, result[1]), 16);
      var g = parseInt(''.padEnd(2, result[2]), 16);
      var b = parseInt(''.padEnd(2, result[3]), 16);
      r /= 255;
      g /= 255;
      b /= 255;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue;
      var saturation;
      var lightness = (max + min) / 2;

      if (max === min) {
        hue = saturation = 0; // achromatic
      } else {
        var d = max - min;
        saturation = lightness > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
          case r:
            hue = (g - b) / d + (g < b ? 6 : 0);
            break;

          case g:
            hue = (b - r) / d + 2;
            break;

          case b:
            hue = (r - g) / d + 4;
            break;
        }

        hue /= 6;
      }

      saturation = Math.round(saturation * 1000);
      saturation = saturation / 10;
      lightness = Math.round(lightness * 1000);
      lightness = lightness / 10;
      hue = Math.round(360 * hue * 10) / 10;
      return new HSLColor(hue, saturation, lightness);
    }
  }, {
    key: "fromHsl",
    value: function fromHsl(hsl) {
      var _HSLColor$HSL_REGEX$e = HSLColor.HSL_REGEX.exec(hsl),
          _HSLColor$HSL_REGEX$e2 = _slicedToArray(_HSLColor$HSL_REGEX$e, 4),
          fullMatch = _HSLColor$HSL_REGEX$e2[0],
          hue = _HSLColor$HSL_REGEX$e2[1],
          saturation = _HSLColor$HSL_REGEX$e2[2],
          lightness = _HSLColor$HSL_REGEX$e2[3];

      return new HSLColor(parseFloat(hue), parseFloat(saturation), parseFloat(lightness));
    }
  }, {
    key: "lighten",
    value: function lighten(color, amount) {
      return HSLColor.of(color).clone().lighten(amount);
    }
  }, {
    key: "darken",
    value: function darken(color, amount) {
      return HSLColor.of(color).clone().darken(amount);
    }
  }, {
    key: "saturate",
    value: function saturate(color, amount) {
      return HSLColor.of(color).clone().saturate(amount);
    }
  }, {
    key: "desaturate",
    value: function desaturate(color, amount) {
      return HSLColor.of(color).clone().desaturate(amount);
    }
  }, {
    key: "hsla",
    value: function hsla(color, amount) {
      return HSLColor.of(color).clone().setAlpha(amount);
    }
  }]);

  return HSLColor;
}();
HSLColor.HSL_REGEX = /(\d{0,3}\.?\d*?), ?(\d{0,3}\.?\d*?)%?, ?(\d{0,3}\.?\d*?)%?/;
HSLColor.HEX_REGEX = /^#([a-f\d]{1,2})([a-f\d]{1,2})([a-f\d]{1,2})$/i;

export { HSLColor };
//# sourceMappingURL=HSLColor.js.map
