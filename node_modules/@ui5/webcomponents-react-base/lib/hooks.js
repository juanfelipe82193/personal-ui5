import { useRef, useMemo, useEffect, useState } from 'react';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { getI18nBundle, fetchI18nBundle } from '@ui5/webcomponents-base/dist/i18nBundle';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { Device } from '@ui5/webcomponents-react-base/lib/Device';

var useConsolidatedRef = function useConsolidatedRef(ref) {
  var localRef = useRef(null);
  var consolidatedRef = useMemo(function () {
    if (!ref || typeof ref === 'function') {
      return localRef;
    }

    return ref;
  }, [ref]);
  useEffect(function () {
    if (typeof ref === 'function') {
      // @ts-ignore
      ref(consolidatedRef.current);
    }
  }, [consolidatedRef.current]);
  return consolidatedRef;
};

var deprecationNotice = function deprecationNotice(component, message) {
  if (process.env.NODE_ENV === 'development') {
    var value = "*** ui5-webcomponents-react Deprecation Notice - ".concat(component, " ***\n"); // eslint-disable-next-line no-console

    console.warn("".concat(value).concat(message));
  }
};

var useDeprecateRenderMethods = function useDeprecateRenderMethods(props, renderMethodName, slotName) {
  useEffect(function () {
    if (props[renderMethodName]) {
      deprecationNotice("".concat(renderMethodName), "The prop '".concat(renderMethodName, "' is deprecated and will be removed in the next major release.\nPlease use '").concat(slotName, "' instead."));
    }
  }, []);
  return useMemo(function () {
    var _props$slotName;

    return (_props$slotName = props[slotName]) !== null && _props$slotName !== void 0 ? _props$slotName : typeof props[renderMethodName] === 'function' ? props[renderMethodName]() : null;
  }, [props[renderMethodName], props[slotName]]);
};

var useI18nBundle = function useI18nBundle(bundleName) {
  var _useState = useState(getI18nBundle(bundleName)),
      _useState2 = _slicedToArray(_useState, 2),
      bundle = _useState2[0],
      setBundle = _useState2[1];

  useEffect(function () {
    var fetchAndLoadBundle = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return fetchI18nBundle(bundleName);

              case 2:
                setBundle(getI18nBundle(bundleName));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function fetchAndLoadBundle() {
        return _ref.apply(this, arguments);
      };
    }();

    fetchAndLoadBundle();
  }, []);
  return bundle;
};

var PROP_WHITELIST = /^(aria-|data-|id$|on[A-Z])/;
var usePassThroughHtmlProps = function usePassThroughHtmlProps(props) {
  var propBlackList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var componentPropBlacklist = new Set(propBlackList);
  var passThroughPropNames = Object.keys(props).filter(function (name) {
    return PROP_WHITELIST.test(name) && !componentPropBlacklist.has(name);
  });
  return useMemo(function () {
    return passThroughPropNames.reduce(function (acc, val) {
      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, val, props[val]));
    }, {});
  }, passThroughPropNames.map(function (name) {
    return props[name];
  }));
};

var useViewportRange = function useViewportRange(rangeSet) {
  var _useState = useState(Device.media.getCurrentRange(rangeSet, window.innerWidth).name),
      _useState2 = _slicedToArray(_useState, 2),
      currentRange = _useState2[0],
      setCurrentRange = _useState2[1];

  var isMounted = useRef(true);
  useEffect(function () {
    var handler = function handler(_ref) {
      var range = _ref.name;

      if (isMounted.current === true) {
        setCurrentRange(range);
      }
    };

    Device.media.attachHandler(handler, null, 'StdExt');
    return function () {
      isMounted.current = false;
      Device.resize.detachHandler(handler, null);
    };
  }, [setCurrentRange, isMounted]);
  return currentRange;
};

export { useConsolidatedRef, useDeprecateRenderMethods, useI18nBundle, usePassThroughHtmlProps, useViewportRange };
//# sourceMappingURL=hooks.js.map
