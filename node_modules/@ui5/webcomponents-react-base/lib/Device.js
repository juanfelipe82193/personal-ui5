import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import { supportTouch, getOS, getBrowser, getSystem } from '@ui5/webcomponents-base/dist/Device';
import _createClass from '@babel/runtime/helpers/createClass';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _createForOfIteratorHelper from '@babel/runtime/helpers/createForOfIteratorHelper';
import '@ui5/webcomponents-react-base/third-party/modernizr';

var EventRegistry = /*#__PURE__*/function () {
  function EventRegistry() {
    _classCallCheck(this, EventRegistry);
  }

  _createClass(EventRegistry, null, [{
    key: "attachEvent",
    value: function attachEvent(sEventId, fnFunction, oListener) {
      if (!EventRegistry.mEventRegistry[sEventId]) {
        EventRegistry.mEventRegistry[sEventId] = [];
      }

      EventRegistry.mEventRegistry[sEventId].push({
        oListener: oListener,
        fFunction: fnFunction
      });
    }
  }, {
    key: "detachEvent",
    value: function detachEvent(sEventId, fnFunction, oListener) {
      var aEventListeners = EventRegistry.mEventRegistry[sEventId];

      if (!aEventListeners) {
        return;
      }

      for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
        if (aEventListeners[i].fFunction === fnFunction && aEventListeners[i].oListener === oListener) {
          aEventListeners.splice(i, 1);
          break;
        }
      }

      if (aEventListeners.length === 0) {
        delete EventRegistry.mEventRegistry[sEventId];
      }
    }
  }, {
    key: "fireEvent",
    value: function fireEvent(sEventId, mParameters) {
      var aEventListeners = EventRegistry.mEventRegistry[sEventId];
      var oInfo;

      if (aEventListeners) {
        aEventListeners = aEventListeners.slice();

        for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
          oInfo = aEventListeners[i];
          oInfo.fFunction.call(oInfo.oListener || window, mParameters);
        }
      }
    }
  }]);

  return EventRegistry;
}();
EventRegistry.mEventRegistry = {};

/* eslint-disable no-console,no-unused-expressions */
var pad0 = function pad0(i, w) {
  return "000".concat(String(i)).slice(-w);
};

var LOG_LEVEL;

(function (LOG_LEVEL) {
  LOG_LEVEL[LOG_LEVEL["FATAL"] = 0] = "FATAL";
  LOG_LEVEL[LOG_LEVEL["ERROR"] = 1] = "ERROR";
  LOG_LEVEL[LOG_LEVEL["WARNING"] = 2] = "WARNING";
  LOG_LEVEL[LOG_LEVEL["INFO"] = 3] = "INFO";
  LOG_LEVEL[LOG_LEVEL["DEBUG"] = 4] = "DEBUG";
  LOG_LEVEL[LOG_LEVEL["TRACE"] = 5] = "TRACE";
})(LOG_LEVEL || (LOG_LEVEL = {}));

var DeviceLogger = /*#__PURE__*/function () {
  function DeviceLogger() {
    var defaultComponent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'DEVICE';

    _classCallCheck(this, DeviceLogger);

    this.defaultComponent = void 0;
    this.sWindowName = window.top === window ? '' : "[".concat(window.location.pathname.split('/').slice(-1)[0], "] ");
    this.log(LOG_LEVEL.INFO, 'Device API logging initialized');
    this.defaultComponent = defaultComponent;
    return this;
  }

  _createClass(DeviceLogger, [{
    key: "for",
    value: function _for(defaultComponent) {
      return new DeviceLogger(defaultComponent);
    }
  }, {
    key: "log",
    value: function log(iLevel, sMessage, sComponent) {
      sComponent = sComponent || this.defaultComponent || '';
      var oNow = new Date();
      var oLogEntry = {
        time: "".concat(pad0(oNow.getHours(), 2), ":").concat(pad0(oNow.getMinutes(), 2), ":").concat(pad0(oNow.getSeconds(), 2)),
        date: "".concat(pad0(oNow.getFullYear(), 4), "-").concat(pad0(oNow.getMonth() + 1, 2), "-").concat(pad0(oNow.getDate(), 2)),
        timestamp: oNow.getTime(),
        level: iLevel,
        message: sMessage || '',
        component: sComponent || ''
      };

      if (window.console) {
        var logText = "".concat(oLogEntry.date, " ").concat(oLogEntry.time, " ").concat(this.sWindowName).concat(oLogEntry.message, " - ").concat(oLogEntry.component);

        switch (iLevel) {
          case LOG_LEVEL.FATAL:
          case LOG_LEVEL.ERROR:
            console.error(logText);
            break;

          case LOG_LEVEL.WARNING:
            console.warn(logText);
            break;

          case LOG_LEVEL.INFO:
            console.info ? console.info(logText) : console.log(logText);
            break;
          // info not available in iOS simulator

          case LOG_LEVEL.DEBUG:
            console.debug ? console.debug(logText) : console.log(logText);
            break;
          // debug not available in IE, fallback to log

          case LOG_LEVEL.TRACE:
            console.trace ? console.trace(logText) : console.log(logText);
            break;
          // trace not available in IE, fallback to log
        }
      }

      return oLogEntry;
    } //  Public API

  }, {
    key: "fatal",
    value: function fatal(msg, component) {
      return this.log(LOG_LEVEL.FATAL, msg, component);
    }
  }, {
    key: "error",
    value: function error(msg, component) {
      return this.log(LOG_LEVEL.ERROR, msg, component);
    }
  }, {
    key: "warning",
    value: function warning(msg, component) {
      return this.log(LOG_LEVEL.WARNING, msg, component);
    }
  }, {
    key: "info",
    value: function info(msg, component) {
      return this.log(LOG_LEVEL.INFO, msg, component);
    }
  }, {
    key: "debug",
    value: function debug(msg, component) {
      return this.log(LOG_LEVEL.DEBUG, msg, component);
    }
  }, {
    key: "trace",
    value: function trace(msg, component) {
      return this.log(LOG_LEVEL.TRACE, msg, component);
    }
  }]);

  return DeviceLogger;
}();

var Logger = new DeviceLogger();

var windowSize = function windowSize() {
  return [window.innerWidth, window.innerHeight];
};
var changeRootCSSClass = function changeRootCSSClass(sClassName, bRemove, sPrefix) {
  var oRoot = document.documentElement;

  if (oRoot.className.length === 0) {
    if (!bRemove) {
      oRoot.className = sClassName;
    }
  } else {
    var aCurrentClasses = oRoot.className.split(' ');
    var sNewClasses = '';
    aCurrentClasses.forEach(function (currentClass) {
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      if (sPrefix && currentClass.indexOf(sPrefix) !== 0 || !sPrefix && currentClass !== sClassName) {
        sNewClasses = "".concat(sNewClasses + currentClass, " ");
      }
    });

    if (!bRemove) {
      sNewClasses += sClassName;
    }

    oRoot.className = sNewClasses;
  }
};
var getQuery = function getQuery(from, to, unit) {
  unit = unit || 'px';
  var q = 'all';

  if (from > 0) {
    q = "".concat(q, " and (min-width:").concat(from).concat(unit, ")");
  }

  if (to > 0) {
    q = "".concat(q, " and (max-width:").concat(to).concat(unit, ")");
  }

  return q;
};
var convertToPx = function convertToPx(val, unit) {
  if (unit === 'em' || unit === 'rem') {
    var _window$getComputedSt;

    var s = (_window$getComputedSt = window.getComputedStyle) !== null && _window$getComputedSt !== void 0 ? _window$getComputedSt : function (element) {
      return element.currentStyle;
    };
    var x = s(document.documentElement).fontSize;
    var f = x && x.indexOf('px') >= 0 ? parseFloat(x) : 16;
    return val * f;
  }

  return val;
};
var matchLegacyBySize = function matchLegacyBySize(from, to, unit, size) {
  from = convertToPx(from, unit);
  to = convertToPx(to, unit);
  var width = size[0];
  var a = from < 0 || from <= width;
  var b = to < 0 || width <= to;
  return a && b;
};

var _Media$predefinedRang;
var RANGESETS; // tslint:disable prefer-for-of variable-name one-variable-per-declaration

(function (RANGESETS) {
  RANGESETS["SAP_3STEPS"] = "3Step";
  RANGESETS["SAP_4STEPS"] = "4Step";
  RANGESETS["SAP_6STEPS"] = "6Step";
  RANGESETS["SAP_STANDARD"] = "Std";
  RANGESETS["SAP_STANDARD_EXTENDED"] = "StdExt";
})(RANGESETS || (RANGESETS = {}));

var support;
var defaultRangeSet = RANGESETS.SAP_STANDARD;
var querysets = {};
var mediaCurrentwidth = null;

var matchLegacy = function matchLegacy(from, to, unit) {
  return matchLegacyBySize(from, to, unit, windowSize());
};

var match = function match(from, to, unit) {
  var q = getQuery(from, to, unit);
  var mm = window.matchMedia(q); // FF returns null when running within an iframe with display:none

  return mm && mm.matches;
};

var refreshCSSClasses = function refreshCSSClasses(sSetName, sRangeName, bRemove) {
  var sClassPrefix = "sapUiMedia-".concat(sSetName, "-");
  changeRootCSSClass(sClassPrefix + sRangeName, bRemove, sClassPrefix);
};

var Media = /*#__PURE__*/function () {
  function Media(supportInstance) {
    _classCallCheck(this, Media);

    this.mediaTimeout = void 0;
    this.matches = void 0;
    this.RANGESETS = RANGESETS;
    support = supportInstance;
    this.mediaTimeout = support.matchmedialistener ? 0 : 100;
    this.matches = support.matchmedia ? match : matchLegacy;
    this.initRangeSet();
    this.initRangeSet(RANGESETS.SAP_STANDARD_EXTENDED);
  }

  _createClass(Media, [{
    key: "checkQueries",
    value: function checkQueries(name, infoOnly, fnMatches) {
      fnMatches = fnMatches || this.matches;

      if (querysets[name]) {
        var aQueries = querysets[name].queries;
        var info = null;

        for (var i = 0, len = aQueries.length; i < len; i++) {
          var q = aQueries[i];

          if ((q !== querysets[name].currentquery || infoOnly) && fnMatches(q.from, q.to, querysets[name].unit)) {
            if (!infoOnly) {
              querysets[name].currentquery = q;
            }

            if (!querysets[name].noClasses && querysets[name].names && !infoOnly) {
              refreshCSSClasses(name, querysets[name].names[i]);
            }

            info = Media.getRangeInfo(name, i);
          }
        }

        return info;
      }

      Logger.warning("No queryset with name ".concat(name, " found"), 'DEVICE.MEDIA');
      return null;
    }
  }, {
    key: "handleChange",
    value: function handleChange(name) {
      var _this = this;

      if (!support.matchmedialistener && mediaCurrentwidth === windowSize()[0]) {
        return; // Skip unnecessary resize events
      }

      if (querysets[name].timer) {
        clearTimeout(querysets[name].timer);
        querysets[name].timer = null;
      }

      querysets[name].timer = setTimeout(function () {
        var mParams = _this.checkQueries(name, false);

        if (mParams) {
          EventRegistry.fireEvent("media_".concat(name), mParams);
        }
      }, this.mediaTimeout);
    }
  }, {
    key: "attachHandler",
    value: function attachHandler(fnFunction, oListener, sName) {
      var name = sName || defaultRangeSet;
      EventRegistry.attachEvent("media_".concat(name), fnFunction, oListener);
    }
  }, {
    key: "detachHandler",
    value: function detachHandler(fnFunction, oListener, sName) {
      var name = sName || defaultRangeSet;
      EventRegistry.detachEvent("media_".concat(name), fnFunction, oListener);
    }
  }, {
    key: "initRangeSet",
    value: function initRangeSet(sName, aRangeBorders, sUnit, aRangeNames, bSuppressClasses) {
      var _this2 = this;

      var oConfig;

      if (!sName) {
        oConfig = Media.predefinedRangeSets[defaultRangeSet];
      } else if (sName && Media.predefinedRangeSets[sName]) {
        oConfig = Media.predefinedRangeSets[sName];
      } else {
        oConfig = {
          name: sName,
          unit: (sUnit || 'px').toLowerCase(),
          points: aRangeBorders || [],
          names: aRangeNames,
          noClasses: !!bSuppressClasses
        };
      }

      if (this.hasRangeSet(oConfig.name)) {
        Logger.info("Range set ".concat(oConfig.name, " has already been initialized"), 'DEVICE.MEDIA');
        return;
      }

      sName = oConfig.name;
      oConfig.queries = [];
      oConfig.timer = null;
      oConfig.currentquery = null;

      oConfig.listener = function () {
        return _this2.handleChange(sName);
      };

      var from;
      var to;
      var query;
      var aPoints = oConfig.points;

      for (var i = 0, len = aPoints.length; i <= len; i++) {
        from = i === 0 ? 0 : aPoints[i - 1];
        to = i === aPoints.length ? -1 : aPoints[i];
        query = getQuery(from, to, oConfig.unit);
        oConfig.queries.push({
          query: query,
          from: from,
          to: to
        });
      }

      if (oConfig.names && oConfig.names.length !== oConfig.queries.length) {
        oConfig.names = null;
      }

      querysets[oConfig.name] = oConfig;

      if (support.matchmedialistener) {
        // FF, Safari, Chrome, IE10?
        var queries = oConfig.queries;

        var _iterator = _createForOfIteratorHelper(queries),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var q = _step.value;
            q.media = window.matchMedia(q.query);
            q.media.addListener(oConfig.listener);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // IE, Safari (<6?)
        window.addEventListener('resize', oConfig.listener, false);
        window.addEventListener('orientationchange', oConfig.listener, false);
      }

      oConfig.listener();
    }
  }, {
    key: "getCurrentRange",
    value: function getCurrentRange(sName, iWidth) {
      if (!this.hasRangeSet(sName)) {
        return null;
      }

      return this.checkQueries(sName, true, isNaN(iWidth) ? null : function (from, to, unit) {
        return matchLegacyBySize(from, to, unit, [iWidth, 0]);
      });
    }
  }, {
    key: "hasRangeSet",
    value: function hasRangeSet(sName) {
      return sName && !!querysets[sName];
    }
  }, {
    key: "removeRangeSet",
    value: function removeRangeSet(sName) {
      if (!this.hasRangeSet(sName)) {
        Logger.info("RangeSet ".concat(sName, " not found, thus could not be removed."), 'DEVICE.MEDIA');
        return;
      }

      for (var x in RANGESETS) {
        if (sName === RANGESETS[x]) {
          Logger.warning('Cannot remove default rangeset - no action taken.', 'DEVICE.MEDIA');
          return;
        }
      }

      var oConfig = querysets[sName];

      if (support.matchmedialistener) {
        // FF, Safari, Chrome, IE10?
        var queries = oConfig.queries;

        var _iterator2 = _createForOfIteratorHelper(queries),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var q = _step2.value;
            q.media.removeListener(oConfig.listener);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        // IE, Safari (<6?)
        window.removeEventListener('resize', oConfig.listener, false);
        window.removeEventListener('orientationchange', oConfig.listener, false);
      }

      refreshCSSClasses(sName, '', true);
      delete EventRegistry.mEventRegistry["media_".concat(sName)];
      delete querysets[sName];
    }
  }], [{
    key: "getRangeInfo",
    value: function getRangeInfo(sSetName, iRangeIdx) {
      var q = querysets[sSetName].queries[iRangeIdx];
      var info = {
        from: q.from,
        unit: querysets[sSetName].unit
      };

      if (q.to >= 0) {
        info.to = q.to;
      }

      if (querysets[sSetName].names) {
        info.name = querysets[sSetName].names[iRangeIdx];
      }

      return info;
    }
  }]);

  return Media;
}();
Media.predefinedRangeSets = (_Media$predefinedRang = {}, _defineProperty(_Media$predefinedRang, RANGESETS.SAP_3STEPS, {
  points: [520, 960],
  unit: 'px',
  name: RANGESETS.SAP_3STEPS,
  names: ['S', 'M', 'L']
}), _defineProperty(_Media$predefinedRang, RANGESETS.SAP_4STEPS, {
  points: [520, 760, 960],
  unit: 'px',
  name: RANGESETS.SAP_4STEPS,
  names: ['S', 'M', 'L', 'XL']
}), _defineProperty(_Media$predefinedRang, RANGESETS.SAP_6STEPS, {
  points: [241, 400, 541, 768, 960],
  unit: 'px',
  name: RANGESETS.SAP_6STEPS,
  names: ['XS', 'S', 'M', 'L', 'XL', 'XXL']
}), _defineProperty(_Media$predefinedRang, RANGESETS.SAP_STANDARD, {
  points: [600, 1024],
  unit: 'px',
  name: RANGESETS.SAP_STANDARD,
  names: ['Phone', 'Tablet', 'Desktop']
}), _defineProperty(_Media$predefinedRang, RANGESETS.SAP_STANDARD_EXTENDED, {
  points: [600, 1024, 1440],
  unit: 'px',
  name: RANGESETS.SAP_STANDARD_EXTENDED,
  names: ['Phone', 'Tablet', 'Desktop', 'LargeDesktop']
}), _Media$predefinedRang);

var Orientation = /*#__PURE__*/function () {
  function Orientation() {
    _classCallCheck(this, Orientation);

    this.landscape = void 0;
    this.portrait = void 0;
  }

  _createClass(Orientation, [{
    key: "attachHandler",
    value: function attachHandler(fnFunction, oListener) {
      EventRegistry.attachEvent('orientation', fnFunction, oListener);
    }
  }, {
    key: "detachHandler",
    value: function detachHandler(fnFunction, oListener) {
      EventRegistry.detachEvent('orientation', fnFunction, oListener);
    }
  }]);

  return Orientation;
}();

var Resize = /*#__PURE__*/function () {
  function Resize() {
    _classCallCheck(this, Resize);

    this.width = void 0;
    this.height = void 0;
    this.setResizeInfo();
  }

  _createClass(Resize, [{
    key: "attachHandler",
    value: function attachHandler(fnFunction, oListener) {
      EventRegistry.attachEvent('resize', fnFunction, oListener);
    }
  }, {
    key: "detachHandler",
    value: function detachHandler(fnFunction, oListener) {
      EventRegistry.detachEvent('resize', fnFunction, oListener);
    }
  }, {
    key: "setResizeInfo",
    value: function setResizeInfo() {
      this.width = windowSize()[0];
      this.height = windowSize()[1];
    }
  }]);

  return Resize;
}();

var Support = function Support() {
  _classCallCheck(this, Support);

  this.touch = supportTouch();
  this.pointer = Modernizr.pointerevents;
  this.matchmedia = Modernizr.matchmedia;
  this.matchmedialistener = !!(this.matchmedia && window.matchMedia('all and (max-width:0px)'));
  this.orientation = Modernizr.deviceorientation;
  this.retina = window.retina || window.devicePixelRatio >= 2;
  this.websocket = Modernizr.websockets;
  this.input = {
    placeholder: Modernizr.placeholder
  };
};

var iResizeTimeout;
var bOrientationChange = false;
var bResize = false;
var iOrientationTimeout;
var iClearFlagTimeout;
var iWindowHeightOld = windowSize()[1];
var iWindowWidthOld = windowSize()[0];
var bKeyboardOpen = false;
var iLastResizeTime;
var rInputTagRegex = /INPUT|TEXTAREA|SELECT/;
var bSkipFirstResize;

var DeviceBuilder = function DeviceBuilder() {
  var _this = this;

  _classCallCheck(this, DeviceBuilder);

  this.os = getOS();
  this.browser = getBrowser();
  this.support = new Support();
  this.system = getSystem();
  this.media = new Media(this.support);
  this.orientation = new Orientation();
  this.resize = new Resize();

  this.handleResizeEvent = function () {
    var wasL = _this.orientation.landscape;

    var isL = _this.isLandscape(false);

    if (wasL !== isL) {
      _this.handleOrientationChange();
    } // throttle resize events because most browsers throw one or more resize events per pixel
    // for every resize event inside the period from 150ms (starting from the first resize event),
    // we only fire one resize event after this period


    if (!iResizeTimeout) {
      iResizeTimeout = window.setTimeout(_this.handleResizeTimeout, 150);
    }
  };

  this.handleResizeTimeout = function () {
    _this.handleResizeChange();

    iResizeTimeout = null;
  };

  this.handleResizeChange = function () {
    _this.resize.setResizeInfo();

    EventRegistry.fireEvent('resize', {
      height: _this.resize.height,
      width: _this.resize.width
    });
  };

  this.setOrientationInfo = function () {
    _this.orientation.landscape = _this.isLandscape(true);
    _this.orientation.portrait = !_this.orientation.landscape;
  };

  this.handleOrientationChange = function () {
    _this.setOrientationInfo();

    EventRegistry.fireEvent('orientation', {
      landscape: _this.orientation.landscape
    });
  };

  this.isLandscape = function (bFromOrientationChange) {
    if (_this.support.touch && _this.support.orientation && _this.os.android) {
      // if on screen keyboard is open and the call of this method is from orientation change listener,
      // reverse the last value. this is because when keyboard opens on android device, the height can be less
      // than the width even in portrait mode.
      if (bKeyboardOpen && bFromOrientationChange) {
        return !_this.orientation.landscape;
      }

      if (bKeyboardOpen) {
        // when keyboard opens, the last orientation change value will be returned.
        return _this.orientation.landscape;
      }
    } else if (_this.support.matchmedia && _this.support.orientation) {
      // most desktop browsers and windows phone/tablet which not support orientationchange
      return !!window.matchMedia('(orientation: landscape)').matches;
    } // otherwise compare the width and height of window


    var size = windowSize();
    return size[0] > size[1];
  };

  this.handleMobileOrientationResizeChange = function (evt) {
    if (evt.type === 'resize') {
      if (bSkipFirstResize && rInputTagRegex.test(document.activeElement.tagName) && !bOrientationChange) {
        return;
      }

      var iWindowHeightNew = windowSize()[1];
      var iWindowWidthNew = windowSize()[0];
      var iTime = new Date().getTime(); // skip multiple resize events by only one orientationchange

      if (iWindowHeightNew === iWindowHeightOld && iWindowWidthNew === iWindowWidthOld) {
        return;
      }

      bResize = true; // on mobile devices opening the keyboard on some devices leads to a resize event
      // in this case only the height changes, not the width

      if (iWindowHeightOld !== iWindowHeightNew && iWindowWidthOld === iWindowWidthNew) {
        // Asus Transformer tablet fires two resize events when orientation changes while keyboard is open.
        // Between these two events, only the height changes. The check of if keyboard is open has to be skipped because
        // it may be judged as keyboard closed but the keyboard is still
        // open which will affect the orientation detection
        if (!iLastResizeTime || iTime - iLastResizeTime > 300) {
          bKeyboardOpen = iWindowHeightNew < iWindowHeightOld;
        }

        _this.handleResizeChange();
      } else {
        iWindowWidthOld = iWindowWidthNew;
      }

      iLastResizeTime = iTime;
      iWindowHeightOld = iWindowHeightNew;

      if (iClearFlagTimeout) {
        window.clearTimeout(iClearFlagTimeout);
        iClearFlagTimeout = null;
      } // Some Android build-in browser fires a resize event after the viewport is applied.
      // This resize event has to be dismissed otherwise when the next orientationchange event happens,
      // a UI5 resize event will be fired with the wrong window size.


      iClearFlagTimeout = window.setTimeout(DeviceBuilder.clearFlags, 1200);
    } else if (evt.type === 'orientationchange') {
      bOrientationChange = true;
    }

    if (iOrientationTimeout) {
      clearTimeout(iOrientationTimeout);
      iOrientationTimeout = null;
    }

    iOrientationTimeout = window.setTimeout(_this.handleMobileTimeout, 50);
  };

  this.handleMobileTimeout = function () {
    // with ios split view, the browser fires only resize event and no orientationchange
    // when changing the size of a split view
    // therefore the following if needs to be adapted with additional check of iPad with version greater or equal 9
    // (splitview was introduced with iOS 9)
    if (bResize && (bOrientationChange || _this.system.tablet && _this.os.ios && _this.os.version >= 9)) {
      _this.handleOrientationChange();

      _this.handleResizeChange();

      bOrientationChange = false;
      bResize = false;

      if (iClearFlagTimeout) {
        window.clearTimeout(iClearFlagTimeout);
        iClearFlagTimeout = null;
      }
    }

    iOrientationTimeout = null;
  };

  // On iPhone with iOS version 7.0.x and on iPad with iOS version 7.x
  // (tested with all versions below 7.1.1), there's an invalid resize event fired
  // when changing the orientation while keyboard is shown.
  bSkipFirstResize = this.os.ios && this.browser.name === 'sf' && (this.system.phone && this.os.version >= 7 && this.os.version < 7.1 || this.system.tablet && this.os.version >= 7); // Add handler for orientationchange and resize after initialization of Device API

  if (this.support.touch && this.support.orientation) {
    // logic for mobile devices which support orientationchange (like ios, android)
    window.addEventListener('resize', this.handleMobileOrientationResizeChange, false);
    window.addEventListener('orientationchange', this.handleMobileOrientationResizeChange, false);
  } else {
    // desktop browsers and windows phone/tablet which not support orientationchange
    window.addEventListener('resize', this.handleResizeEvent, false);
  }

  this.setOrientationInfo();
};

DeviceBuilder.clearFlags = function () {
  bOrientationChange = false;
  bResize = false;
  iClearFlagTimeout = null;
};

var Device = new DeviceBuilder();

export { Device };
//# sourceMappingURL=Device.js.map
