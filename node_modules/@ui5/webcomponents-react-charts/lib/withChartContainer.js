import _extends from '@babel/runtime/helpers/extends';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React, { useState, useRef, useCallback, useEffect, forwardRef, useMemo } from 'react';
import { createUseStyles } from 'react-jss';
import { Loader } from '@ui5/webcomponents-react/lib/Loader';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import debounce from 'lodash.debounce';

var loaderStyles = {
  position: 'absolute'
};
var getLoadingState = function getLoadingState(loading, datasets, Placeholder) {
  if (!loading) {
    return null;
  }

  if (loading && datasets.length > 0) {
    return /*#__PURE__*/React.createElement(Loader, {
      style: loaderStyles
    });
  }

  if (loading && datasets.length === 0) {
    return /*#__PURE__*/React.createElement(Placeholder, null);
  }

  return null;
};

var useSizeMonitor = function useSizeMonitor(props, container) {
  var heightProp = props.height,
      widthProp = props.width,
      minHeight = props.minHeight,
      minWidth = props.minWidth;

  var _useState = useState({
    height: null,
    width: null
  }),
      _useState2 = _slicedToArray(_useState, 2),
      sizeState = _useState2[0],
      setSizeState = _useState2[1];

  var observer = useRef(null);
  var dynamicHeightProp = typeof heightProp === 'string';
  var dynamicWidthProp = typeof heightProp === 'string';
  var enableSizeMonitor = dynamicHeightProp || dynamicWidthProp;
  var recalculateSize = useCallback(function (e) {
    var clientRectHeight;
    var clientRectWidth;

    if (!e || !e[0] || !e[0].contentRect) {
      clientRectHeight = container.current.getBoundingClientRect().height;
      clientRectWidth = container.current.getBoundingClientRect().width;
    } else {
      clientRectHeight = e[0].contentRect.height;
      clientRectWidth = e[0].contentRect.width;
    }

    if (dynamicHeightProp || dynamicWidthProp) {
      setSizeState(function (state) {
        return _objectSpread(_objectSpread(_objectSpread({}, state), dynamicHeightProp && {
          height: Math.max(minHeight, clientRectHeight)
        }), dynamicWidthProp && {
          width: Math.max(minWidth, clientRectWidth)
        });
      });
    }
  }, [setSizeState, minWidth, minHeight, dynamicHeightProp, dynamicWidthProp]);
  useEffect(function () {
    if (enableSizeMonitor && container.current) {
      // @ts-ignore
      observer.current = new ResizeObserver(debounce(recalculateSize, 500));
      observer.current.observe(container.current);
    }

    return function () {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [recalculateSize]);
  return {
    height: dynamicHeightProp ? sizeState.height : heightProp,
    width: dynamicWidthProp ? sizeState.width : widthProp
  };
};

var calculateChartHeight = function calculateChartHeight(props) {
  if (props.noLegend) {
    return typeof props.height === 'string' ? props.height : "".concat(props.height, "px");
  }

  return typeof props.height === 'string' ? "calc(".concat(props.height, " - 60px)") : "".concat(props.height - 60, "px");
};

var styles = {
  chart: {
    '& .legend': {
      height: '55px',
      maxHeight: '55px',
      marginTop: '5px',
      overflowY: 'auto',
      display: 'flex',
      flexWrap: 'wrap',
      padding: '0 1rem',
      boxSizing: 'border-box'
    },
    '& > svg[role="img"]': {
      width: function width(props) {
        return "".concat(props.width, "px");
      },
      height: calculateChartHeight
    }
  }
};
var useStyles = createUseStyles(styles, {
  name: 'ChartContainer'
});
var withChartContainer = function withChartContainer(Component) {
  var ChartContainer = forwardRef(function (props, ref) {
    var style = props.style,
        className = props.className,
        tooltip = props.tooltip,
        loading = props.loading,
        datasets = props.datasets,
        slot = props.slot,
        noLegend = props.noLegend,
        rest = _objectWithoutProperties(props, ["style", "className", "tooltip", "loading", "datasets", "slot", "noLegend"]);

    var outerContainer = useRef(null);
    var legendRef = useRef(null);
    var classes = useStyles(props);
    var classNames = classes.chart;

    if (className) {
      classNames = "".concat(classNames, " ").concat(className);
    }

    var loadingIndicator = useMemo(function () {
      return getLoadingState(loading, datasets, Component.LoadingPlaceholder);
    }, [loading, datasets, Component]);

    var _useSizeMonitor = useSizeMonitor(props, outerContainer),
        height = _useSizeMonitor.height,
        width = _useSizeMonitor.width;

    var inlineStyle = useMemo(function () {
      return _objectSpread({
        position: 'relative',
        paddingTop: '6px',
        width: typeof props.width === 'string' ? props.width : "".concat(width, "px"),
        height: typeof props.height === 'string' ? props.height : "".concat(height, "px")
      }, style);
    }, [props.width, props.height, width, height, style]);
    var chartHeight = useMemo(function () {
      return noLegend ? height : height - 60;
    }, [noLegend, height]);
    var chartWrapperStyles = useMemo(function () {
      var innerChartWrapperStyles = {
        position: 'relative',
        height: chartHeight >= 0 ? "".concat(chartHeight, "px") : 'auto',
        width: width ? "".concat(width, "px") : 'auto'
      };
      return innerChartWrapperStyles;
    }, [chartHeight, width]);
    return /*#__PURE__*/React.createElement("div", {
      ref: outerContainer,
      className: classNames,
      style: inlineStyle,
      title: tooltip,
      slot: slot
    }, loadingIndicator, height && datasets.length > 0 && /*#__PURE__*/React.createElement("div", {
      style: chartWrapperStyles
    }, /*#__PURE__*/React.createElement(Component, _extends({}, rest, {
      noLegend: noLegend,
      height: chartHeight,
      width: width,
      ref: ref,
      datasets: datasets,
      loading: loading,
      legendRef: legendRef
    }))), /*#__PURE__*/React.createElement("div", {
      ref: legendRef,
      className: "legend"
    }));
  });
  ChartContainer.defaultProps = Component.defaultProps;
  ChartContainer.displayName = Component.displayName;
  return ChartContainer;
};

export { withChartContainer };
//# sourceMappingURL=withChartContainer.js.map
