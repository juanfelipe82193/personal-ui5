import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { ThemingParameters } from '@ui5/webcomponents-react-base/lib/ThemingParameters';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/lib/useConsolidatedRef';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/lib/Utils';
import { BarChartPlaceholder } from '@ui5/webcomponents-react-charts/lib/BarChartPlaceholder';
import { ChartDataLabel } from '@ui5/webcomponents-react-charts/lib/components/ChartDataLabel';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/YAxisTicks';
import { ChartContainer } from '@ui5/webcomponents-react-charts/lib/next/ChartContainer';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/lib/useLegendItemClick';
import React, { useMemo, useState, useRef, useEffect, useCallback, forwardRef } from 'react';
import { BarChart as BarChart$1, CartesianGrid, XAxis, YAxis, Bar, Legend, ReferenceLine, Tooltip, Brush } from 'recharts';
import { getTextWidth } from '@ui5/webcomponents-react-charts/lib/Utils';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';
import debounce from 'lodash.debounce';

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabelBar = function useLongestYAxisLabelBar(dataset, elements) {
  return useMemo(function () {
    var axisWidths = Array(elements.length).fill(0);
    var marginLeft = 0;

    if (dataset instanceof Array && elements) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return elementConfig.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      var allFormattedDataLabels = dataset.map(resolveAllMeasureLabels);
      allFormattedDataLabels.forEach(function (dimensionLabels) {
        dimensionLabels.forEach(function (label, dimensionIndex) {
          axisWidths[dimensionIndex] = Math.max(getTextWidth(label), axisWidths[dimensionIndex]);
        });
      });
      axisWidths = axisWidths.map(function (length) {
        return Math.min(defaultMaxYAxisWidth, length);
      });
      marginLeft = axisWidths.reduce(function (acc, val) {
        return acc + val;
      }, 0);
    }

    return [axisWidths, {
      marginLeft: marginLeft,
      maxWidth: "calc(100% - ".concat(marginLeft + 8, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && measure.formatter && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
};

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};

/**
 * <code>import { BarChart } from '@ui5/webcomponents-react-charts/lib/next/BarChart';</code>
 */
var BarChart = forwardRef(function (props, ref) {
  var loading = props.loading,
      dataset = props.dataset,
      _props$noLegend = props.noLegend,
      noLegend = _props$noLegend === void 0 ? false : _props$noLegend,
      _props$noAnimation = props.noAnimation,
      noAnimation = _props$noAnimation === void 0 ? false : _props$noAnimation,
      onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot;
  var chartConfig = useMemo(function () {
    return _objectSpread({
      margin: {},
      yAxisVisible: true,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      barGap: 3,
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var tooltipValueFormatter = useTooltipFormatter(measures);
  var primaryDimension = dimensions[0];
  var primaryMeasure = measures[0];
  var chartRef = useConsolidatedRef(ref);
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var onDataPointClickInternal = useCallback(function (payload, i, event) {
    if (payload && onDataPointClick) {
      var value = payload.value.length ? payload.value[1] - payload.value[0] : payload.value;
      onDataPointClick(enrichEventWithDetails(event, {
        dataKey: Object.keys(payload).filter(function (key) {
          return key !== 'value';
        }).find(function (key) {
          return payload[key] === value;
        }),
        value: value,
        payload: payload.payload,
        dataIndex: i
      }));
    }
  }, [onDataPointClick]);
  var isBigDataSet = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30;
  var primaryDimensionAccessor = primaryDimension === null || primaryDimension === void 0 ? void 0 : primaryDimension.accessor;

  var _useLongestYAxisLabel = useLongestYAxisLabelBar(dataset, dimensions),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      width = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);

  var _useObserveXAxisHeigh = useObserveXAxisHeights(chartRef, 1),
      _useObserveXAxisHeigh2 = _slicedToArray(_useObserveXAxisHeigh, 1),
      xAxisHeight = _useObserveXAxisHeigh2[0];

  return /*#__PURE__*/React.createElement(ChartContainer, {
    dataset: dataset,
    loading: loading,
    Placeholder: BarChartPlaceholder,
    ref: chartRef,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, /*#__PURE__*/React.createElement(BarChart$1, {
    margin: marginChart,
    layout: "vertical",
    data: dataset,
    barGap: chartConfig.barGap,
    className: typeof onDataPointClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && /*#__PURE__*/React.createElement(XAxis, {
    interval: 0,
    type: "number",
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: primaryMeasure
    }),
    axisLine: chartConfig.xAxisVisible,
    tickLine: tickLineConfig,
    tickFormatter: primaryMeasure === null || primaryMeasure === void 0 ? void 0 : primaryMeasure.formatter,
    height: xAxisHeight
  }), chartConfig.yAxisVisible && dimensions.map(function (dimension, index) {
    var _dimension$interval;

    return /*#__PURE__*/React.createElement(YAxis, {
      interval: (_dimension$interval = dimension === null || dimension === void 0 ? void 0 : dimension.interval) !== null && _dimension$interval !== void 0 ? _dimension$interval : isBigDataSet ? 'preserveStart' : 0,
      type: "category",
      key: dimension.accessor,
      dataKey: dimension.accessor,
      xAxisId: index,
      tick: /*#__PURE__*/React.createElement(YAxisTicks, {
        config: dimension
      }),
      tickLine: index < 1,
      axisLine: index < 1,
      yAxisId: index,
      width: width[index],
      allowDuplicatedCategory: index === 0
    });
  }), measures.map(function (element, index) {
    var _element$label, _element$color, _element$color2;

    return /*#__PURE__*/React.createElement(Bar, {
      stackId: element.stackId,
      fillOpacity: element.opacity,
      key: element.accessor,
      name: (_element$label = element.label) !== null && _element$label !== void 0 ? _element$label : element.accessor,
      strokeOpacity: element.opacity,
      label: /*#__PURE__*/React.createElement(ChartDataLabel, {
        config: element,
        chartType: "bar",
        position: "insideRight"
      }),
      type: "monotone",
      dataKey: element.accessor,
      fill: (_element$color = element.color) !== null && _element$color !== void 0 ? _element$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      stroke: (_element$color2 = element.color) !== null && _element$color2 !== void 0 ? _element$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      barSize: element.width,
      onClick: onDataPointClickInternal,
      isAnimationActive: noAnimation === false
    });
  }), !noLegend && /*#__PURE__*/React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    x: chartConfig.referenceLine.value,
    label: chartConfig.referenceLine.label
  }), /*#__PURE__*/React.createElement(Tooltip, {
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle
  }), chartConfig.zoomingTool && /*#__PURE__*/React.createElement(Brush, {
    y: 10,
    dataKey: primaryDimensionAccessor,
    stroke: ThemingParameters.sapObjectHeader_BorderColor,
    travellerWidth: 10,
    height: 20
  })));
});
BarChart.displayName = 'BarChart';

export { BarChart };
//# sourceMappingURL=BarChart.js.map
