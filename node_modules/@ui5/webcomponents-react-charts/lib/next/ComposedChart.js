import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { ThemingParameters } from '@ui5/webcomponents-react-base/lib/ThemingParameters';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/lib/useConsolidatedRef';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/lib/Utils';
import { ChartDataLabel } from '@ui5/webcomponents-react-charts/lib/components/ChartDataLabel';
import { ComposedChartPlaceholder } from '@ui5/webcomponents-react-charts/lib/components/ComposedChartPlaceholder';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/YAxisTicks';
import { ChartContainer } from '@ui5/webcomponents-react-charts/lib/next/ChartContainer';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/lib/useLegendItemClick';
import React, { useMemo, useState, useRef, useEffect, useCallback, forwardRef } from 'react';
import { Line, Bar, Area, ComposedChart as ComposedChart$1, CartesianGrid, YAxis, XAxis, ReferenceLine, Tooltip, Legend, Brush } from 'recharts';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { getTextWidth } from '@ui5/webcomponents-react-charts/lib/Utils';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';
import debounce from 'lodash.debounce';

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabel = function useLongestYAxisLabel(dataset, elements) {
  return useMemo(function () {
    var labelLength = 0;
    var primaryElement = elements[0];

    if (dataset instanceof Array && primaryElement) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return primaryElement.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      labelLength = Math.max.apply(Math, _toConsumableArray(dataset.map(resolveAllMeasureLabels).flat().map(getTextWidth)));
      labelLength += 8;
    }

    labelLength = Math.min(labelLength, defaultMaxYAxisWidth);
    return [labelLength, {
      marginLeft: labelLength,
      maxWidth: "calc(100% - ".concat(labelLength + 10, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && measure.formatter && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
};

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};
var ChartTypes;

(function (ChartTypes) {
  ChartTypes[ChartTypes["line"] = Line] = "line";
  ChartTypes[ChartTypes["bar"] = Bar] = "bar";
  ChartTypes[ChartTypes["area"] = Area] = "area";
})(ChartTypes || (ChartTypes = {}));

/**
 * <code>import { ComposedChart } from '@ui5/webcomponents-react-charts/lib/next/ComposedChart';</code>
 */
var ComposedChart = forwardRef(function (props, ref) {
  var _ref2, _chartConfig$secondYA2, _chartConfig$secondYA3, _chartConfig$secondYA4, _chartConfig$secondYA5;

  var loading = props.loading,
      dataset = props.dataset,
      onDataPointClick = props.onDataPointClick,
      _props$noLegend = props.noLegend,
      noLegend = _props$noLegend === void 0 ? false : _props$noLegend,
      _props$noAnimation = props.noAnimation,
      noAnimation = _props$noAnimation === void 0 ? false : _props$noAnimation,
      onLegendClick = props.onLegendClick,
      _props$layout = props.layout,
      layout = _props$layout === void 0 ? 'horizontal' : _props$layout,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot;
  var chartRef = useConsolidatedRef(ref);
  var chartConfig = useMemo(function () {
    return _objectSpread({
      yAxisVisible: false,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var tooltipValueFormatter = useTooltipFormatter(measures);
  var primaryDimension = dimensions[0];
  var primaryMeasure = measures[0];
  var dataKeys = measures.map(function (_ref) {
    var accessor = _ref.accessor;
    return accessor;
  });
  var colorSecondY = chartConfig.secondYAxis ? dataKeys.findIndex(function (key) {
    var _chartConfig$secondYA;

    return key === ((_chartConfig$secondYA = chartConfig.secondYAxis) === null || _chartConfig$secondYA === void 0 ? void 0 : _chartConfig$secondYA.dataKey);
  }) : 0;
  var onDataPointClickInternal = useCallback(function (payload, eventOrIndex, event) {
    if (payload.name) {
      var _payload$index, _payload$dataKey;

      typeof onDataPointClick === 'function' && onDataPointClick(enrichEventWithDetails(event !== null && event !== void 0 ? event : eventOrIndex, {
        value: payload.value.length ? payload.value[1] - payload.value[0] : payload.value,
        dataIndex: (_payload$index = payload.index) !== null && _payload$index !== void 0 ? _payload$index : eventOrIndex,
        dataKey: payload.value.length ? Object.keys(payload).filter(function (key) {
          return payload.value.length ? payload[key] === payload.value[1] - payload.value[0] : payload[key] === payload.value && key !== 'value';
        })[0] : (_payload$dataKey = payload.dataKey) !== null && _payload$dataKey !== void 0 ? _payload$dataKey : Object.keys(payload).find(function (key) {
          return payload[key] === payload.value && key !== 'value';
        }),
        payload: payload.payload
      }));
    } else {
      typeof onDataPointClick === 'function' && onDataPointClick(enrichEventWithDetails({}, {
        value: eventOrIndex.value,
        dataKey: eventOrIndex.dataKey,
        dataIndex: eventOrIndex.index,
        payload: eventOrIndex.payload
      }));
    }
  }, [onDataPointClick]);
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var isBigDataSet = (_ref2 = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30) !== null && _ref2 !== void 0 ? _ref2 : false;
  var primaryDimensionAccessor = primaryDimension === null || primaryDimension === void 0 ? void 0 : primaryDimension.accessor;

  var _useLongestYAxisLabel = useLongestYAxisLabel(dataset, layout === 'vertical' ? dimensions : measures),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      yAxisWidth = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);
  var xAxisHeights = useObserveXAxisHeights(chartRef, layout === 'vertical' ? 1 : props.dimensions.length);
  var measureAxisProps = {
    axisLine: chartConfig.yAxisVisible,
    tickLine: tickLineConfig,
    tickFormatter: primaryMeasure === null || primaryMeasure === void 0 ? void 0 : primaryMeasure.formatter,
    interval: 0
  };
  var Placeholder = useCallback(function () {
    return /*#__PURE__*/React.createElement(ComposedChartPlaceholder, {
      layout: layout,
      measures: measures
    });
  }, [layout, measures]);
  return /*#__PURE__*/React.createElement(ChartContainer, {
    ref: chartRef,
    loading: loading,
    dataset: dataset,
    Placeholder: Placeholder,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, /*#__PURE__*/React.createElement(ComposedChart$1, {
    margin: marginChart,
    data: dataset,
    layout: layout,
    className: typeof onDataPointClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && dimensions.map(function (dimension, index) {
    var _dimension$interval;

    var AxisComponent;
    var axisProps = {
      dataKey: dimension.accessor,
      interval: (_dimension$interval = dimension === null || dimension === void 0 ? void 0 : dimension.interval) !== null && _dimension$interval !== void 0 ? _dimension$interval : isBigDataSet ? 'preserveStart' : 0,
      tickLine: index < 1,
      axisLine: index < 1,
      allowDuplicatedCategory: index === 0,
      scale: dimensions.length === 1 ? 'band' : 'auto'
    };

    if (layout === 'vertical') {
      axisProps.type = 'category';
      axisProps.tick = /*#__PURE__*/React.createElement(YAxisTicks, {
        config: dimension
      });
      axisProps.yAxisId = index;
      axisProps.width = yAxisWidth;
      AxisComponent = YAxis;
    } else {
      axisProps.dataKey = dimension.accessor;
      axisProps.tick = /*#__PURE__*/React.createElement(XAxisTicks, {
        config: dimension
      });
      axisProps.xAxisId = index;
      axisProps.height = xAxisHeights[index];
      AxisComponent = XAxis;
    }

    return /*#__PURE__*/React.createElement(AxisComponent, _extends({
      key: dimension.accessor
    }, axisProps));
  }), layout === 'horizontal' && /*#__PURE__*/React.createElement(YAxis, _extends({}, measureAxisProps, {
    yAxisId: "primary",
    width: yAxisWidth,
    tick: /*#__PURE__*/React.createElement(YAxisTicks, {
      config: primaryMeasure
    })
  })), layout === 'vertical' && /*#__PURE__*/React.createElement(XAxis, _extends({}, measureAxisProps, {
    xAxisId: "primary",
    type: "number",
    tick: /*#__PURE__*/React.createElement(XAxisTicks, {
      config: primaryMeasure
    })
  })), ((_chartConfig$secondYA2 = chartConfig.secondYAxis) === null || _chartConfig$secondYA2 === void 0 ? void 0 : _chartConfig$secondYA2.dataKey) && layout === 'horizontal' && /*#__PURE__*/React.createElement(YAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    stroke: (_chartConfig$secondYA3 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA3 !== void 0 ? _chartConfig$secondYA3 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")"),
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: "right",
    interval: 0,
    yAxisId: "secondary"
  }), ((_chartConfig$secondYA4 = chartConfig.secondYAxis) === null || _chartConfig$secondYA4 === void 0 ? void 0 : _chartConfig$secondYA4.dataKey) && layout === 'vertical' && /*#__PURE__*/React.createElement(XAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    stroke: (_chartConfig$secondYA5 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA5 !== void 0 ? _chartConfig$secondYA5 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")"),
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: "top",
    interval: 0,
    xAxisId: "secondary",
    type: "number"
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    y: layout === 'horizontal' ? chartConfig.referenceLine.value : undefined,
    x: layout === 'vertical' ? chartConfig.referenceLine.value : undefined,
    label: chartConfig.referenceLine.label,
    yAxisId: layout === 'horizontal' ? 'primary' : undefined,
    xAxisId: layout === 'vertical' ? 'primary' : undefined
  }), /*#__PURE__*/React.createElement(Tooltip, {
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle
  }), !noLegend && /*#__PURE__*/React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), measures === null || measures === void 0 ? void 0 : measures.map(function (element, index) {
    var _element$stackId, _element$label, _element$color, _element$color2;

    var ChartElement = ChartTypes[element.type];
    var chartElementProps = {
      isAnimationActive: noAnimation === false
    };
    var labelPosition = 'top';

    switch (element.type) {
      case 'line':
        chartElementProps.activeDot = {
          onClick: onDataPointClickInternal
        };
        chartElementProps.strokeWidth = element.width;
        chartElementProps.strokeOpacity = element.opacity;
        chartElementProps.dot = !isBigDataSet;
        break;

      case 'bar':
        chartElementProps.fillOpacity = element.opacity;
        chartElementProps.strokeOpacity = element.opacity;
        chartElementProps.barSize = element.width;
        chartElementProps.onClick = onDataPointClickInternal;
        chartElementProps.stackId = (_element$stackId = element.stackId) !== null && _element$stackId !== void 0 ? _element$stackId : undefined;
        chartElementProps.labelPosition = element.stackId ? 'insideTop' : 'top';

        if (layout === 'vertical') {
          labelPosition = 'insideRight';
        } else {
          labelPosition = 'insideTop';
        }

        break;

      case 'area':
        chartElementProps.dot = !isBigDataSet;
        chartElementProps.fillOpacity = 0.3;
        chartElementProps.strokeOpacity = element.opacity;
        chartElementProps.onClick = onDataPointClickInternal;
        chartElementProps.strokeWidth = element.width;
        break;
    }

    if (layout === 'vertical') {
      var _chartConfig$secondYA6;

      chartElementProps.xAxisId = ((_chartConfig$secondYA6 = chartConfig.secondYAxis) === null || _chartConfig$secondYA6 === void 0 ? void 0 : _chartConfig$secondYA6.dataKey) === element.accessor ? 'secondary' : 'primary';
    } else {
      var _chartConfig$secondYA7;

      chartElementProps.yAxisId = ((_chartConfig$secondYA7 = chartConfig.secondYAxis) === null || _chartConfig$secondYA7 === void 0 ? void 0 : _chartConfig$secondYA7.dataKey) === element.accessor ? 'secondary' : 'primary';
    }

    return /*#__PURE__*/React.createElement(ChartElement, _extends({
      key: element.accessor,
      name: (_element$label = element.label) !== null && _element$label !== void 0 ? _element$label : element.accessor,
      label: isBigDataSet ? null : /*#__PURE__*/React.createElement(ChartDataLabel, {
        config: element,
        chartType: element.type,
        position: labelPosition
      }),
      stroke: (_element$color = element.color) !== null && _element$color !== void 0 ? _element$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      fill: (_element$color2 = element.color) !== null && _element$color2 !== void 0 ? _element$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      type: "monotone",
      dataKey: element.accessor
    }, chartElementProps));
  }), chartConfig.zoomingTool && /*#__PURE__*/React.createElement(Brush, {
    y: 10,
    dataKey: primaryDimensionAccessor,
    stroke: ThemingParameters.sapObjectHeader_BorderColor,
    travellerWidth: 10,
    height: 20
  })));
});
ComposedChart.displayName = 'ComposedChart';

export { ComposedChart };
//# sourceMappingURL=ComposedChart.js.map
