import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { ThemingParameters } from '@ui5/webcomponents-react-base/lib/ThemingParameters';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/lib/useConsolidatedRef';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/lib/Utils';
import { ColumnChartPlaceholder } from '@ui5/webcomponents-react-charts/lib/ColumnChartPlaceholder';
import { ChartDataLabel } from '@ui5/webcomponents-react-charts/lib/components/ChartDataLabel';
import { XAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/XAxisTicks';
import { YAxisTicks } from '@ui5/webcomponents-react-charts/lib/components/YAxisTicks';
import { ChartContainer } from '@ui5/webcomponents-react-charts/lib/next/ChartContainer';
import { useLegendItemClick } from '@ui5/webcomponents-react-charts/lib/useLegendItemClick';
import React, { useMemo, useState, useRef, useEffect, useCallback, forwardRef } from 'react';
import { BarChart, CartesianGrid, XAxis, YAxis, Bar, Legend, ReferenceLine, Tooltip, Brush } from 'recharts';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { getTextWidth } from '@ui5/webcomponents-react-charts/lib/Utils';
import { getValueByDataKey } from 'recharts/lib/util/ChartUtils';
import debounce from 'lodash.debounce';

var useChartMargin = function useChartMargin(margin, hasZoomingTool) {
  return useMemo(function () {
    var _margin$right, _margin$top, _margin$bottom, _margin$left;

    return {
      right: (_margin$right = margin === null || margin === void 0 ? void 0 : margin.right) !== null && _margin$right !== void 0 ? _margin$right : 30,
      top: ((_margin$top = margin === null || margin === void 0 ? void 0 : margin.top) !== null && _margin$top !== void 0 ? _margin$top : hasZoomingTool) ? 40 : 20,
      bottom: (_margin$bottom = margin === null || margin === void 0 ? void 0 : margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 20,
      left: (_margin$left = margin === null || margin === void 0 ? void 0 : margin.left) !== null && _margin$left !== void 0 ? _margin$left : 10
    };
  }, [margin, hasZoomingTool]);
};

var defaultFormatter = function defaultFormatter(d) {
  return d;
};
var defaultMaxYAxisWidth = 200;

var useLongestYAxisLabel = function useLongestYAxisLabel(dataset, elements) {
  return useMemo(function () {
    var labelLength = 0;
    var primaryElement = elements[0];

    if (dataset instanceof Array && primaryElement) {
      var resolveAllMeasureLabels = function resolveAllMeasureLabels(item) {
        return elements.map(function (elementConfig) {
          return primaryElement.formatter(getValueByDataKey(item, elementConfig.accessor, ''));
        });
      };

      labelLength = Math.max.apply(Math, _toConsumableArray(dataset.map(resolveAllMeasureLabels).flat().map(getTextWidth)));
      labelLength += 8;
    }

    labelLength = Math.min(labelLength, defaultMaxYAxisWidth);
    return [labelLength, {
      marginLeft: labelLength,
      maxWidth: "calc(100% - ".concat(labelLength + 10, "px)")
    }];
  }, [dataset, elements]);
};

var defaultAxisHeight = 30;
var useObserveXAxisHeights = function useObserveXAxisHeights(chartRef, axisCount) {
  var _useState = useState(Array(axisCount).fill(defaultAxisHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      xAxisHeights = _useState2[0],
      setXAxisHeights = _useState2[1];

  var mostRecentXAxisHeights = useRef(xAxisHeights);
  useEffect(function () {
    var mutationObserver = new MutationObserver(debounce(function () {
      var _chartRef$current;

      var defaultHeights = Array(axisCount).fill(defaultAxisHeight);
      (_chartRef$current = chartRef.current) === null || _chartRef$current === void 0 ? void 0 : _chartRef$current.querySelectorAll('.xAxis').forEach(function (xAxis, index) {
        var _xAxis$getBBox;

        var currentAxisHeight = xAxis === null || xAxis === void 0 ? void 0 : (_xAxis$getBBox = xAxis.getBBox()) === null || _xAxis$getBBox === void 0 ? void 0 : _xAxis$getBBox.height;

        if (currentAxisHeight > 30) {
          defaultHeights[index] = currentAxisHeight;
        }
      });
      var arraysHaveTheSameLength = mostRecentXAxisHeights.current.length === defaultHeights.length;
      var arrayContentIsIdentical = mostRecentXAxisHeights.current.every(function (value, index) {
        return defaultHeights[index] === value;
      });

      if (!(arraysHaveTheSameLength && arrayContentIsIdentical)) {
        mostRecentXAxisHeights.current = defaultHeights;
        setXAxisHeights(defaultHeights);
      }
    }, 75));

    if (chartRef.current) {
      mutationObserver.observe(chartRef.current, {
        characterData: false,
        characterDataOldValue: false,
        attributes: false,
        childList: true,
        subtree: true
      });
    }

    return function () {
      mutationObserver.disconnect();
    };
  }, [chartRef, setXAxisHeights, mostRecentXAxisHeights]);
  return xAxisHeights;
};

var usePrepareDimensionsAndMeasures = function usePrepareDimensionsAndMeasures(rawDimensions, rawMeasures) {
  var dimensionDefaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var measureDefaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dimensions = useMemo(function () {
    return rawDimensions.map(function (label) {
      return _objectSpread(_objectSpread({}, dimensionDefaults), label);
    });
  }, [rawDimensions, dimensionDefaults]);
  var measures = useMemo(function () {
    return rawMeasures.map(function (value) {
      return _objectSpread(_objectSpread({}, measureDefaults), value);
    });
  }, [rawMeasures, measureDefaults]);
  return {
    dimensions: dimensions,
    measures: measures
  };
};

var useTooltipFormatter = function useTooltipFormatter(measures) {
  return useCallback(function (value, name, props) {
    var measure = measures.find(function (_ref) {
      var accessor = _ref.accessor;
      return accessor === props.dataKey;
    });

    if (measure && measure.formatter && typeof measure.formatter === 'function') {
      return measure.formatter(value);
    }

    return value;
  }, [measures]);
};

var tickLineConfig = {
  stroke: 'transparent'
};
var tooltipContentStyle = {
  backgroundColor: ThemingParameters.sapBackgroundColor
};
var tooltipFillOpacity = {
  fillOpacity: 0.3
};

var dimensionDefaults = {
  formatter: defaultFormatter
};
var measureDefaults = {
  formatter: defaultFormatter,
  opacity: 1
};
/**
 * <code>import { ColumnChart } from '@ui5/webcomponents-react-charts/lib/next/ColumnChart';</code>
 */

var ColumnChart = forwardRef(function (props, ref) {
  var _ref2, _chartConfig$secondYA2, _chartConfig$secondYA3;

  var loading = props.loading,
      dataset = props.dataset,
      _props$noLegend = props.noLegend,
      noLegend = _props$noLegend === void 0 ? false : _props$noLegend,
      _props$noAnimation = props.noAnimation,
      noAnimation = _props$noAnimation === void 0 ? false : _props$noAnimation,
      onDataPointClick = props.onDataPointClick,
      onLegendClick = props.onLegendClick,
      style = props.style,
      className = props.className,
      tooltip = props.tooltip,
      slot = props.slot;
  var chartConfig = useMemo(function () {
    return _objectSpread({
      yAxisVisible: false,
      xAxisVisible: true,
      gridStroke: ThemingParameters.sapList_BorderColor,
      gridHorizontal: true,
      gridVertical: false,
      legendPosition: 'bottom',
      legendHorizontalAlign: 'left',
      barGap: 3,
      zoomingTool: false,
      resizeDebounce: 250
    }, props.chartConfig);
  }, [props.chartConfig]);

  var _usePrepareDimensions = usePrepareDimensionsAndMeasures(props.dimensions, props.measures, dimensionDefaults, measureDefaults),
      dimensions = _usePrepareDimensions.dimensions,
      measures = _usePrepareDimensions.measures;

  var tooltipValueFormatter = useTooltipFormatter(measures);

  var _useLongestYAxisLabel = useLongestYAxisLabel(dataset, measures),
      _useLongestYAxisLabel2 = _slicedToArray(_useLongestYAxisLabel, 2),
      yAxisWidth = _useLongestYAxisLabel2[0],
      legendPosition = _useLongestYAxisLabel2[1];

  var primaryDimension = dimensions[0];
  var primaryMeasure = measures[0];
  var chartRef = useConsolidatedRef(ref);
  var dataKeys = measures.map(function (_ref) {
    var accessor = _ref.accessor;
    return accessor;
  });
  var colorSecondY = chartConfig.secondYAxis ? dataKeys.findIndex(function (key) {
    var _chartConfig$secondYA;

    return key === ((_chartConfig$secondYA = chartConfig.secondYAxis) === null || _chartConfig$secondYA === void 0 ? void 0 : _chartConfig$secondYA.dataKey);
  }) : 0;
  var onItemLegendClick = useLegendItemClick(onLegendClick);
  var onDataPointClickInternal = useCallback(function (payload, eventOrIndex, event) {
    if (payload && onDataPointClick) {
      onDataPointClick(enrichEventWithDetails(event, {
        dataKey: Object.keys(payload).filter(function (key) {
          return payload.value.length ? payload[key] === payload.value[1] - payload.value[0] : payload[key] === payload.value && key !== 'value';
        })[0],
        value: payload.value.length ? payload.value[1] - payload.value[0] : payload.value,
        dataIndex: eventOrIndex,
        payload: payload.payload
      }));
    }
  }, [onDataPointClick]);
  var isBigDataSet = (_ref2 = (dataset === null || dataset === void 0 ? void 0 : dataset.length) > 30) !== null && _ref2 !== void 0 ? _ref2 : false;
  var primaryDimensionAccessor = primaryDimension === null || primaryDimension === void 0 ? void 0 : primaryDimension.accessor;
  var marginChart = useChartMargin(chartConfig.margin, chartConfig.zoomingTool);
  var xAxisHeights = useObserveXAxisHeights(chartRef, props.dimensions.length);
  return /*#__PURE__*/React.createElement(ChartContainer, {
    dataset: dataset,
    loading: loading,
    Placeholder: ColumnChartPlaceholder,
    ref: chartRef,
    style: style,
    className: className,
    tooltip: tooltip,
    slot: slot,
    resizeDebounce: chartConfig.resizeDebounce
  }, /*#__PURE__*/React.createElement(BarChart, {
    margin: marginChart,
    data: dataset,
    barGap: chartConfig.barGap,
    className: typeof onDataPointClick === 'function' ? 'has-click-handler' : undefined
  }, /*#__PURE__*/React.createElement(CartesianGrid, {
    vertical: chartConfig.gridVertical,
    horizontal: chartConfig.gridHorizontal,
    stroke: chartConfig.gridStroke
  }), chartConfig.xAxisVisible && dimensions.map(function (dimension, index) {
    var _dimension$interval;

    return /*#__PURE__*/React.createElement(XAxis, {
      key: dimension.accessor,
      dataKey: dimension.accessor,
      xAxisId: index,
      interval: (_dimension$interval = dimension === null || dimension === void 0 ? void 0 : dimension.interval) !== null && _dimension$interval !== void 0 ? _dimension$interval : isBigDataSet ? 'preserveStart' : 0,
      tick: /*#__PURE__*/React.createElement(XAxisTicks, {
        config: dimension
      }),
      tickLine: index < 1,
      axisLine: index < 1,
      height: xAxisHeights[index],
      allowDuplicatedCategory: index === 0
    });
  }), /*#__PURE__*/React.createElement(YAxis, {
    axisLine: chartConfig.yAxisVisible,
    tickLine: tickLineConfig,
    yAxisId: "left",
    interval: 0,
    tick: /*#__PURE__*/React.createElement(YAxisTicks, {
      config: primaryMeasure
    }),
    width: yAxisWidth
  }), ((_chartConfig$secondYA2 = chartConfig.secondYAxis) === null || _chartConfig$secondYA2 === void 0 ? void 0 : _chartConfig$secondYA2.dataKey) && /*#__PURE__*/React.createElement(YAxis, {
    dataKey: chartConfig.secondYAxis.dataKey,
    stroke: (_chartConfig$secondYA3 = chartConfig.secondYAxis.color) !== null && _chartConfig$secondYA3 !== void 0 ? _chartConfig$secondYA3 : "var(--sapChart_OrderedColor_".concat(colorSecondY % 11 + 1, ")"),
    label: {
      value: chartConfig.secondYAxis.name,
      offset: 2,
      angle: +90,
      position: 'center'
    },
    orientation: "right",
    yAxisId: "right",
    interval: 0
  }), measures.map(function (element, index) {
    var _chartConfig$secondYA4, _element$label, _element$color, _element$color2;

    return /*#__PURE__*/React.createElement(Bar, {
      yAxisId: ((_chartConfig$secondYA4 = chartConfig.secondYAxis) === null || _chartConfig$secondYA4 === void 0 ? void 0 : _chartConfig$secondYA4.dataKey) === element.accessor ? 'right' : 'left',
      stackId: element.stackId,
      fillOpacity: element.opacity,
      key: element.accessor,
      name: (_element$label = element.label) !== null && _element$label !== void 0 ? _element$label : element.accessor,
      strokeOpacity: element.opacity,
      label: /*#__PURE__*/React.createElement(ChartDataLabel, {
        config: element,
        chartType: "column",
        position: 'insideTop'
      }),
      type: "monotone",
      dataKey: element.accessor,
      fill: (_element$color = element.color) !== null && _element$color !== void 0 ? _element$color : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      stroke: (_element$color2 = element.color) !== null && _element$color2 !== void 0 ? _element$color2 : "var(--sapChart_OrderedColor_".concat(index % 11 + 1, ")"),
      barSize: element.width,
      onClick: onDataPointClickInternal,
      isAnimationActive: noAnimation === false
    });
  }), !noLegend && /*#__PURE__*/React.createElement(Legend, {
    verticalAlign: chartConfig.legendPosition,
    align: chartConfig.legendHorizontalAlign,
    onClick: onItemLegendClick,
    wrapperStyle: legendPosition
  }), chartConfig.referenceLine && /*#__PURE__*/React.createElement(ReferenceLine, {
    stroke: chartConfig.referenceLine.color,
    y: chartConfig.referenceLine.value,
    label: chartConfig.referenceLine.label,
    yAxisId: 'left'
  }), /*#__PURE__*/React.createElement(Tooltip, {
    cursor: tooltipFillOpacity,
    formatter: tooltipValueFormatter,
    contentStyle: tooltipContentStyle
  }), chartConfig.zoomingTool && /*#__PURE__*/React.createElement(Brush, {
    y: 10,
    dataKey: primaryDimensionAccessor,
    stroke: ThemingParameters.sapObjectHeader_BorderColor,
    travellerWidth: 10,
    height: 20
  })));
});
ColumnChart.displayName = 'ColumnChart';

export { ColumnChart };
//# sourceMappingURL=ColumnChart.js.map
