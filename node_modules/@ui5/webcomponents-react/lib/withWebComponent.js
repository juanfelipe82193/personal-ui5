import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import { useConsolidatedRef } from '@ui5/webcomponents-react-base/lib/useConsolidatedRef';
import { polyfillDeprecatedEventAPI } from '@ui5/webcomponents-react-base/lib/Utils';
import React, { forwardRef, useRef, useMemo, Children, cloneElement, useEffect } from 'react';

var capitalizeFirstLetter = function capitalizeFirstLetter(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
};

var toKebabCase = function toKebabCase(s) {
  return s.replace(/([A-Z])/g, function (a, b) {
    return "-".concat(b.toLowerCase());
  });
};

var createEventWrapperFor = function createEventWrapperFor(eventIdentifier, eventHandler) {
  return function (event) {
    polyfillDeprecatedEventAPI(event);
    return eventHandler(event);
  };
};

var withWebComponent = function withWebComponent(TagName, regularProperties, booleanProperties, slotProperties, eventProperties) {
  var WithWebComponent = forwardRef(function (props, wcRef) {
    var className = props.className,
        tooltip = props.tooltip,
        children = props.children,
        rest = _objectWithoutProperties(props, ["className", "tooltip", "children"]);

    var ref = useConsolidatedRef(wcRef);
    var eventRegistry = useRef({});
    var eventRegistryWrapped = useRef({}); // regular props (no booleans, no slots and no events)

    var regularProps = useMemo(function () {
      return regularProperties.reduce(function (acc, val) {
        if (rest.hasOwnProperty(val)) {
          return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, toKebabCase(val), rest[val]));
        }

        return acc;
      }, {});
    }, regularProperties.map(function (name) {
      return rest[name];
    })); // boolean properties - only attach if they are truthy

    var booleanProps = useMemo(function () {
      return booleanProperties.reduce(function (acc, val) {
        if (rest[val] === true || rest[val] === 'true') {
          return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, toKebabCase(val), true));
        }

        return acc;
      }, {});
    }, booleanProperties.map(function (name) {
      return rest[name];
    }));
    var slots = useMemo(function () {
      return Object.entries(rest).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            slotName = _ref2[0];

        return slotProperties.includes(slotName);
      }).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            slotName = _ref4[0],
            slotValue = _ref4[1];

        return Children.map((slotValue === null || slotValue === void 0 ? void 0 : slotValue.type) === React.Fragment ? slotValue.props.children : slotValue, function (item, index) {
          return cloneElement(item, {
            key: "".concat(slotName, "-").concat(index),
            slot: slotName
          });
        });
      });
    }, slotProperties.map(function (name) {
      return rest[name];
    })); // event binding

    useEffect(function () {
      eventProperties.forEach(function (eventName) {
        var eventHandler = rest["on".concat(capitalizeFirstLetter(eventName))];

        if (typeof eventHandler === 'function' && eventRegistry.current[eventName] !== eventHandler) {
          if (eventRegistry.current[eventName]) {
            ref.current.removeEventListener(eventName, eventRegistryWrapped.current[eventName]);
          }

          eventRegistryWrapped.current[eventName] = createEventWrapperFor(eventName, eventHandler);
          ref.current.addEventListener(eventName, eventRegistryWrapped.current[eventName]);
          eventRegistry.current[eventName] = eventHandler;
        } else if (eventRegistry.current[eventName] && !eventHandler) {
          ref.current.removeEventListener(eventName, eventRegistryWrapped.current[eventName]);
        }
      });
    }, eventProperties.map(function (eventName) {
      return rest["on".concat(capitalizeFirstLetter(eventName))];
    })); // non web component related props, just pass them

    var nonWebComponentRelatedProps = Object.entries(rest).filter(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          key = _ref6[0];

      return !regularProperties.includes(key);
    }).filter(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 1),
          key = _ref8[0];

      return !slotProperties.includes(key);
    }).filter(function (_ref9) {
      var _ref10 = _slicedToArray(_ref9, 1),
          key = _ref10[0];

      return !booleanProperties.includes(key);
    }).filter(function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 1),
          key = _ref12[0];

      return !eventProperties.map(function (val) {
        return "on".concat(capitalizeFirstLetter(val));
      }).includes(key);
    }).reduce(function (acc, _ref13) {
      var _ref14 = _slicedToArray(_ref13, 2),
          key = _ref14[0],
          val = _ref14[1];

      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, val));
    }, {});
    return (
      /*#__PURE__*/
      // @ts-ignore
      React.createElement(TagName, _extends({
        ref: ref
      }, booleanProps, regularProps, nonWebComponentRelatedProps, {
        "class": className,
        title: tooltip
      }), slots, children)
    );
  });
  WithWebComponent.displayName = "WithWebComponent(".concat(TagName, ")");
  return WithWebComponent;
};

export { withWebComponent };
//# sourceMappingURL=withWebComponent.js.map
